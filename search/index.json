[{"content":"初始化博客 在桌面右键,选择在终端打开,然后输入以下命令\n1 hugo new site blog 然后桌面会出现一个名为blog的文件夹,可以用VScode打开文件夹并打开终端进行后续操作\n🎈hugo-theme-stack安装 删掉默认的配置文件config.toml\n打开终端输入以下命令\n1 2 git init #获取主题文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 将获取到的主题文件中的exampleSite中的config.yaml拷贝到blog根目录中\n并进行配置,根据自己需要进行配置,这里我贴出自己的配置图共参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 baseurl: myblog languageCode: zh-cn theme: hugo-theme-stack paginate: 5 title: TauZZ\u0026#39;s Blog languages: # en: # languageName: English # title: Example Site # description: Example description # weight: 1 zh-cn: languageName: 中文 title: TauZZ\u0026#39;s Blog description: 👋Welcome To TauZZ\u0026#39;s Blog weight: 1 # ar: # languageName: عربي # languagedirection: rtl # title: موقع تجريبي # description: وصف تجريبي # weight: 3 # Change it to your Disqus shortname before using disqusShortname: hugo-theme-stack # GA Tracking ID googleAnalytics: # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn # Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko] # This will make .Summary and .WordCount behave correctly for CJK languages. hasCJKLanguage: false permalinks: post: /p/:slug/ page: /:slug/ params: mainSections: - post featuredImageField: image rssFullContent: true favicon: img/favicon.ico # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) footer: since: 2020 customText: dateFormat: published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST sidebar: emoji: 🍥 subtitle: 加油努力.✍️ avatar: enabled: true local: true src: img/avatar.png article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 comments: enabled: true provider: waline disqusjs: shortname: apiUrl: apiKey: admin: adminLabel: utterances: repo: issueTerm: pathname label: remark42: host: site: locale: vssue: platform: owner: repo: clientId: clientSecret: autoCreateIssue: false # Waline client configuration see: https://waline.js.org/en/reference/component.html waline: serverURL: lang: pageview: emoji: - https://cdn.jsdelivr.net/npm/sticker-heo@2022.7.5/Sticker-100/ requiredMeta: - name - email locale: admin: 👻屑博主 placeholder: 🎉留下你的脚印. twikoo: envId: region: path: lang: # See https://cactus.chat/docs/reference/web-client/#configuration for description of the various options cactus: defaultHomeserverUrl: \u0026#34;https://matrix.cactus.chat:8448\u0026#34; serverName: \u0026#34;cactus.chat\u0026#34; siteName: \u0026#34;\u0026#34; # You must insert a unique identifier here matching the one you registered (See https://cactus.chat/docs/getting-started/quick-start/#register-your-site) giscus: repo: repoID: category: categoryID: mapping: lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 gitalk: owner: admin: repo: clientID: clientSecret: cusdis: host: id: widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc opengraph: twitter: # Your Twitter username site: # Available values: summary, summary_large_image card: summary_large_image defaultImage: opengraph: enabled: false local: false src: colorScheme: # Display toggle toggle: true # Available values: auto, light, dark default: light imageProcessing: cover: enabled: true content: enabled: true ### Custom menu ### See https://docs.stack.jimmycai.com/configuration/custom-menu.html ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter menu: main: [] social: - identifier: github name: GitHub url: https://github.com/Tauzi params: icon: brand-github - identifier: weixin name: Dreamq0p params: icon: wx related: includeNewer: true threshold: 60 toLower: false indices: - name: tags weight: 100 - name: categories weight: 200 markup: goldmark: renderer: ## Set to true if you have HTML content inside Markdown unsafe: false tableOfContents: endLevel: 4 ordered: true startLevel: 2 highlight: noClasses: false codeFences: true guessSyntax: true lineNoStart: 1 lineNos: true lineNumbersInTable: true tabWidth: 4 \u0026gt; 官方配置文档: [https://stack.jimmycai.com/config/](https://stack.jimmycai.com/config/)\r🎈完成配置后 然后在自己的站点目录输入：hugo server\n在浏览器输入：localhost:1313 得到以下页面： 🎈开始创作 博客文章主要都存放在content中,这里可以参考一下我的content文件夹布局,例如我现在想要创建一篇文章,我们可以在blog根目录下打开终端输入hugo new post/2022/XXXX.md这条命令的意思是在conent/post/2023里创建一个名为XXXX.md的文件\n文章格式例如 1 2 3 4 5 6 7 8 9 10 11 --- title: Chinese Test description: 这是一个副标题 date: 2020-09-09 slug: test-chinese image: helena-hertz-wWZzXlDpMog-unsplash.jpg categories: - Test - 测试 tags: --- Hugo博客配合Action部署到Github 创建仓库等步骤略过 🎈部署hugo博客 1.接下来我们在我们的博客根目录下创建一个名为.github的文件夹,然后在文件夹里新建一个新的文件夹,名字为workflows,接着进入workflows文件夹里新建一个名为deploy.xml的文件,再在deploy.xml里填入如下内容,最终目录为~\\blog.github\\workflows\\deploy.xml,将deploy.xml中的external_repository项里的lin-snow改为你GitHub注册时的名字即可\ndeploy.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 name: GitHub Page on: push: branches: - gh-pages # master 更新触发 jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # clone submodules fetch-depth: 0 # 克隆所有历史信息 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.111.3\u0026#34; # Hugo 版本 extended: true # hugo插件版 Stack主题 必须启用 - name: Cache resources # 缓存 resource 文件加快生成速度 uses: actions/cache@v2 with: path: resources # 检查照片文件变化 key: ${{ runner.os }}-hugocache-${{ hashFiles(\u0026#39;content/**/*\u0026#39;) }} restore-keys: ${{ runner.os }}-hugocache- - name: Build # 生成网页 删除无用 resource 文件 削减空行 run: hugo --minify --gc - name: Deploy # 部署到 GitHub Page uses: peaceiris/actions-gh-pages@v3 with: # 如果在同一个仓库下使用请使用 github_token 并注释 deploy_key # github_token: ${{ secrets.GITHUB_TOKEN }} deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # 如果在同一个仓库请注释 external_repository: Tauzi/myblog # 你的 GitHub page 仓库 example/example.github.io publish_dir: ./public user_name: \u0026#34;github-actions[bot]\u0026#34; user_email: \u0026#34;github-actions[bot]@users.noreply.github.com\u0026#34; full_commit_message: Deploy from ${{ github.repository }}@${{ github.sha }} 🚀 2.然后在博客根目录文件夹下新建一个名为deploy.sh的文件用于一键部署博客,在deploy.sh中填入如下内容\n1 2 3 4 5 6 7 8 9 10 11 hugo --theme=hugo-theme-stack --baseUrl=https://tauzi.github.io/myblog/ --buildDrafts cd public git init #初始化git git add -A git commit -m \u0026#39;deploy123\u0026#39; git push -f git@github.com:Tauzi/myblog.git master:gh-pages #向存储库推送 用git执行 bash deploy.sh 这样就可以把hugo生成的html文件推送到仓库gh-pages分支\n🎈开启Github Page 等待Github Action完成后,我们需要开启GitHub page,首先进入blog这个仓库,然后打开设置,找到page项,根据如下设置即可. 等待完成构建后就可以访问了!\n","date":"2023-05-09T00:00:00Z","image":"https://tauzi.github.io/myblog/p/suibi/1_huc6c8a4f3d1059672265c0e5adae6d2de_603933_120x120_fill_q75_box_smart1.jpg","permalink":"https://tauzi.github.io/myblog/p/suibi/","title":"hugo搭建"},{"content":"精尽 Netty 面试题 以下面试题，转载芋道源码\nBIO 是什么？ 🦅 概念\nBIO ，全称 Block-IO ，是一种阻塞 + 同步的通信模式。\n是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。\n🦅 原理\n服务器通过一个 Acceptor 线程，负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的一请求一应答模式。\n若客户端数量增多，频繁地创建和销毁线程会给服务器打开很大的压力。后改良为用线程池的方式代替新增线程，被称为伪异步 IO 。\n🦅 示例\n代码参见 bio 。 🦅 小结\nBIO 模型中，通过 Socket 和 ServerSocket 实现套接字通道的通信。阻塞，同步，建立连接耗时。\nNIO 是什么？ 🦅 概念\nNIO ，全称 New IO ，也叫 Non-Block IO ，是一种非阻塞 + 同步的通信模式。\n《精尽 Netty 源码分析 —— NIO 基础（一）之简介》\n🦅 原理\nNIO 相对于 BIO 来说一大进步。客户端和服务器之间通过 Channel 通信。NIO 可以在 Channel 进行读写操作。这些 Channel 都会被注册在 Selector 多路复用器上。Selector 通过一个线程不停的轮询这些 Channel 。找出已经准备就绪的 Channel 执行 IO 操作。\nNIO 通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞 NIO 的特点。\n服务器端只要提供一个线程负责 Selector 的轮询，就可以接入成千上万个客户端，这就是 JDK NIO 库的巨大进步。\n《精尽 Netty 源码分析 —— NIO 基础（四）之 Selector》\n通道分为两大类：一类是网络读写（SelectableChannel），一类是用于文件操作（FileChannel）。我们使用的是前者 SocketChannel 和 ServerSocketChannel ，都是SelectableChannel 的子类。\n《精尽 Netty 源码分析 —— NIO 基础（二）之 Channel》\nBIO 是将数据直接写入或读取到流 Stream 对象中。\nNIO 的数据操作都是在 Buffer 中进行的。Buffer 实际上是一个数组。Buffer 最常见的类型是ByteBuffer，另外还有 CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。\n《精尽 Netty 源码分析 —— NIO 基础（三）之 Buffer》\n缓冲区 Buffer ：它是 NIO 与 BIO 的一个重要区别。\n通道 Channel ：和流 Stream 不同，通道是双向的。NIO可以通过 Channel 进行数据的读、写和同时读写操作。\n多路复用器 Selector ：NIO 编程的基础。多路复用器提供选择已经就绪的任务的能力：就是 Selector 会不断地轮询注册在其上的通道（Channel），如果某个通道处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以取得就绪的Channel集合，从而进行后续的 IO 操作。\n🦅 示例\n代码参见 nio\n《精尽 Netty 源码分析 —— NIO 基础（五）之示例》\n🦅 小结\nNIO 模型中通过 SocketChannel 和 ServerSocketChannel 实现套接字通道的通信。非阻塞，同步，避免为每个 TCP 连接创建一个线程。\n🦅 继续挖掘\n可能有胖友对非阻塞和阻塞，同步和异步的定义有点懵逼，我们再来看下 《精尽 Netty 源码分析 —— NIO 基础（一）之简介》 提到的一段话：\n老艿艿：在一些文章中，会将 Java NIO 描述成异步 IO ，实际是不太正确的： Java NIO 是同步 IO ，Java AIO ( 也称为 NIO 2 )是异步 IO。具体原因，推荐阅读文章：\n《异步和非阻塞一样吗? (内容涉及 BIO, NIO, AIO, Netty)》 。\n《BIO与NIO、AIO的区别(这个容易理解)》\n总结来说，在 Unix IO 模型的语境下：\n同步和异步的区别：数据拷贝阶段是否需要完全由操作系统处理。\n阻塞和非阻塞操作：是针对发起 IO 请求操作后，是否有立刻返回一个标志信息而不让请求线程等待。\n因此，Java NIO 是同步且非阻塞的 IO 。\n另外，胖友在瞅瞅下面这个图来理解下：Unix 的 5 种 IO 模型 AIO 是什么？ 艿艿：这个面试题，重点在于陈述我们对 BIO、NIO 的理解，对于 AIO 来说，基本理解即可。\n🦅 概念\nAIO ，全称 Asynchronous IO ，也叫 NIO2 ，是一种非阻塞 + 异步的通信模式。在 NIO 的基础上，引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。\n原理：\nAIO 并没有采用 NIO 的多路复用器，而是使用异步通道的概念。其 read，write 方法的返回类型，都是 Future 对象。而 Future 模型是异步的，其核心思想是：去主函数等待时间。\n🦅 示例\n代码参见 aio 🦅 小结\nAIO 模型中通过 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel 实现套接字通道的通信。非阻塞，异步。\nBIO、NIO 有什么区别？ 线程模型不同\nBIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。所以，线程开销大。可改良为用线程池的方式代替新创建线程，被称为伪异步 IO 。\nNIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有新的 I/O 请求时，才启动一个线程进行处理。可改良为一个线程处理多个请求，基于 多 Reactor 模型。\nBIO 是面向流( Stream )的，而 NIO 是面向缓冲区( Buffer )的。\nBIO 的各种操作是阻塞的，而 NIO 的各种操作是非阻塞的。\nBIO 的 Socket 是单向的，而 NIO 的 Channel 是双向的。\n可能文字比较难记，整理出来就是下图：BIO 对比 NIO 对比 AIO\n有一点要注意，虽然图中说 NIO 的性能一般，但是在绝大多数我们日常业务场景，NIO 和 AIO 的性能差距实际没这么大。在 Netty5 中，基于 AIO 改造和支持，最后发现，性能并没有想象中这么强悍，所以 Netty5 被废弃，而是继续保持 Netty4 为主版本，使用 NIO 为主。 为了胖友能更好的记住和理解 BIO、NIO、AIO 的流程，胖友可以在理解下图：BIO、NIO、AIO 的流程图\n什么是 Netty ？ Netty 是一款提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。\n也就是说，Netty 是一个基于 NIO 的客户、服务器端编程框架。使用 Netty 可以确保你快速和简单地开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty 相当简化和流线化了网络应用的编程开发过程，例如，TCP 和 UDP 的 socket 服务开发。\n（以上摘自百度百科）。\nNetty 具有如下特性( 摘自《Netty in Action》 )\n分类\nNetty的特性\n设计\n1. 统一的 API ，支持多种传输类型( 阻塞和非阻塞的 ) 2. 简单而强大的线程模型 3. 真正的无连接数据报套接字( UDP )支持 4. 连接逻辑组件( ChannelHander 中顺序处理消息 )以及组件复用( 一个 ChannelHandel 可以被多个ChannelPipeLine 复用 )\n易于使用\n1. 详实的 Javadoc 和大量的示例集 2. 不需要超过 JDK 1.6+ 的依赖\n性能\n拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟( 得益于池化和复用 )，更低的资源消耗以及最少的内存复制\n健壮性\n1. 不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError 2. 消除在高速网络中 NIO 应用程序常见的不公平读 / 写比率\n安全性\n完整的 SSL/TLS 以及 StartTLs 支持，可用于受限环境下，如 Applet 和 OSGI\n社区驱动\n发布快速而且频繁\n为什么选择 Netty ？ 使用简单：API 使用简单，开发门槛低。\n功能强大：预置了多种编解码功能，支持多种主流协议。\n定制能力强：可以通过 ChannelHandler 对通信框架进行灵活的扩展。\n性能高：通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优。\n成熟稳定：Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼。\n社区活跃：版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入。\n案例丰富：经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。\n实际上，这个也是我们做技术选型的一些参考点，不仅仅适用于 Netty ，也同样适用于其他技术栈。当然，😈 面试都可以酱紫回答，显得很高端。\n为什么说 Netty 使用简单？ 🦅 我们假设要搭建一个 Server 服务器，使用 Java NIO 的步骤如下：\n创建 ServerSocketChannel 。 绑定监听端口，并配置为非阻塞模式。 创建 Selector，将之前创建的 ServerSocketChannel 注册到 Selector 上，监听 SelectionKey.OP_ACCEPT 。 循环执行 Selector#select() 方法，轮询就绪的 Channel。 轮询就绪的 Channel 时，如果是处于 OP_ACCEPT 状态，说明是新的客户端接入，调用 ServerSocketChannel#accept() 方法，接收新的客户端。 设置新接入的 SocketChannel 为非阻塞模式，并注册到 Selector 上，监听 OP_READ 。 如果轮询的 Channel 状态是 OP_READ ，说明有新的就绪数据包需要读取，则构造 ByteBuffer 对象，读取数据。 这里，解码数据包的过程，需要我们自己编写。 艿艿：注意噢，上述步骤还是最简的 Java NIO 启动步骤，不包括多 Reactor 多线程模型噢！可能有胖友不知道什么是 Reactor 模型，在 「什么是 Reactor 模型？」 问题中，我们会详细解释。\n🦅 使用 Netty 的步骤如下：\n创建 NIO 线程组 EventLoopGroup 和 ServerBootstrap。 设置 ServerBootstrap 的属性：线程组、SO_BACKLOG 选项，设置 NioServerSocketChannel 为 Channel\n设置业务处理 Handler 和 编解码器 Codec 。\n绑定端口，启动服务器程序。\n在业务处理 Handler 中，处理客户端发送的数据，并给出响应。 🦅 那么相比 Java NIO，使用 Netty 开发程序，都简化了哪些步骤呢？\n无需关心 OP_ACCEPT、OP_READ、OP_WRITE 等等 IO 操作，Netty 已经封装，对我们在使用是透明无感的。\n使用 boss 和 worker EventLoopGroup ，Netty 直接提供多 Reactor 多线程模型。\n在 Netty 中，我们看到有使用一个解码器 FixedLengthFrameDecoder，可以用于处理定长消息的问题，能够解决 TCP 粘包拆包问题，十分方便。如果使用 Java NIO ，需要我们自行实现解码器。\n😈 如果胖友不知道如何使用 Java NIO 编写一个 Server ，建议自己去实现以下。 😈 如果胖友没有使用过 Netty 编写一个 Server ，建议去入门下。\n说说业务中 Netty 的使用场景？ 构建高性能、低时延的各种 Java 中间件，Netty 主要作为基础通信框架提供高性能、低时延的通信服务。例如：\nRocketMQ ，分布式消息队列。\nDubbo ，服务调用框架。\nSpring WebFlux ，基于响应式的 Web 框架。\nHDFS ，分布式文件系统。\n公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket、Protobuf 等协议的支持。\n各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。\n说说 Netty 如何实现高性能？ 线程模型 ：更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel 。\n内存池设计 ：使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁。并且，内吃吃的内部实现是用一颗二叉查找树，更好的管理内存分配情况。\n内存零拷贝 ：使用 Direct Buffer ，可以使用 Zero-Copy 机制。\nZero-Copy ，在操作数据时，不需要将数据 Buffer 从一个内存区域拷贝到另一个内存区域。因为少了一次内存的拷贝，因此 CPU 的效率就得到的提升。\n协议支持 ：提供对 Protobuf 等高性能序列化协议支持。\n使用更多本地代码。例如：\n直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。\n利用 JNI 提供了 Native Socket Transport ，在使用 Epoll edge-triggered 的情况下，可以有一定的性能提升。\n其它： 利用反射等技术直接操纵 SelectionKey ，使用数组而不是 Java 容器等。\n实现 FastThreadLocal 类，当请求频繁时，带来更好的性能。\n\u0026hellip;.\n另外，推荐阅读白衣大大的两篇文章：\n《Netty高性能编程备忘录(上)》\n《Netty高性能编程备忘录（下）》\n下面三连问！\nNetty 是一个高性能的、高可靠的、可扩展的异步通信框架，那么高性能、高可靠、可扩展设计体现在哪里呢？\nNetty 的高性能如何体现？ 这个问题，和 「说说 Netty 如何实现高性能？」 问题，会有点重叠。没事，反正理解就好，也背不下来。哈哈哈哈。\n性能是设计出来的，而不是测试出来的。那么，Netty 的架构设计是如何实现高性能的呢？\n线程模型 ：采用异步非阻塞的 I/O 类库，基于 Reactor 模式实现，解决了传统同步阻塞 I/O 模式下服务端无法平滑处理客户端线性增长的问题。\n堆外内存 ：TCP 接收和发送缓冲区采用直接内存代替堆内存，避免了内存复制，提升了 I/O 读取和写入性能。\n内存池设计 ：支持通过内存池的方式循环利用 ByteBuf，避免了频繁创建和销毁 ByteBuf 带来的性能消耗。\n参数配置 ：可配置的 I/O 线程数目和 TCP 参数等，为不同用户提供定制化的调优参数，满足不同的性能场景。\n队列优化 ：采用环形数组缓冲区，实现无锁化并发编程，代替传统的线程安全容器或锁。\n并发能力 ：合理使用线程安全容器、原子类等，提升系统的并发能力。\n降低锁竞争 ：关键资源的使用采用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的 CPU 资源消耗问题。\n内存泄露检测 ：通过引用计数器及时地释放不再被引用的对象，细粒度的内存管理降低了 GC 的频率，减少频繁 GC 带来的时延增大和 CPU 损耗。\n《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》 Netty 的高可靠如何体现？ 链路有效性检测：由于长连接不需要每次发送消息都创建链路，也不需要在消息完成交互时关闭链路，因此相对于短连接性能更高。为了保证长连接的链路有效性，往往需要通过心跳机制周期性地进行链路检测。使用心跳机制的原因是，避免在系统空闲时因网络闪断而断开连接，之后又遇到海量业务冲击导致消息积压无法处理。为了解决这个问题，需要周期性地对链路进行有效性检测，一旦发现问题，可以及时关闭链路，重建 TCP 连接。为了支持心跳，Netty 提供了两种链路空闲检测机制： 读空闲超时机制：连续 T 周期没有消息可读时，发送心跳消息，进行链路检测。如果连续 N 个周期没有读取到心跳消息，可以主动关闭链路，重建连接。\n写空闲超时机制：连续 T 周期没有消息需要发送时，发送心跳消息，进行链路检测。如果连续 N 个周期没有读取对方发回的心跳消息，可以主动关闭链路，重建连接。\n《精尽 Netty 源码解析 —— ChannelHandler（五）之 IdleStateHandler》\n内存保护机制：Netty 提供多种机制对内存进行保护，包括以下几个方面： 通过对象引用计数器对 ByteBuf 进行细粒度的内存申请和释放，对非法的对象引用进行检测和保护。\n可设置的内存容量上限，包括 ByteBuf、线程池线程数等，避免异常请求耗光内存。\n优雅停机：优雅停机功能指的是当系统推出时，JVM 通过注册的 Shutdown Hook 拦截到退出信号量，然后执行推出操作，释放相关模块的资源占用，将缓冲区的消息处理完成或清空，将待刷新的数据持久化到磁盘和数据库中，等到资源回收和缓冲区消息处理完成之后，再退出。 《精尽 Netty 源码解析 —— EventLoop（八）之 EventLoop 优雅关闭》 Netty 的可扩展如何体现？ 可定制、易扩展。\n责任链模式 ：ChannelPipeline 基于责任链模式开发，便于业务逻辑的拦截、定制和扩展。\n基于接口的开发 ：关键的类库都提供了接口或抽象类，便于用户自定义实现。\n提供大量的工厂类 ：通过重载这些工厂类，可以按需创建出用户需要的对象。\n提供大量系统参数 ：供用户按需设置，增强系统的场景定制性。\n艿艿：说个题外话。\n实际上，任何的技术的研究，我们都可以去思考，它的高性能是怎么体现的，它的可靠性是怎么体现的，它的可拓展是怎么体现的。\n当然，因为很多时候有近义词，所以：\n高性能 =\u0026gt; 高并发\n可靠性 =\u0026gt; 高可用\n可拓展 =\u0026gt; 高拓展\n例如说，MySQL 如何实现高性能，MySQL 如何搭建高可用，😈 MySQL 如何做拓展貌似暂时没，哈哈哈哈。\n简单介绍 Netty 的核心组件？ Netty 有如下六个核心组件：\nBootstrap \u0026amp; ServerBootstrap\nChannel\nChannelFuture\nEventLoop \u0026amp; EventLoopGroup\nChannelHandler\nChannelPipeline\n详细的，请直接阅读 《精尽 Netty 源码分析 —— Netty 简介（二）之核心组件》 一文。\n说说 Netty 的逻辑架构？ Netty 采用了典型的三层网络架构进行设计和开发，其逻辑架构如下图所示：\nNetty 逻辑架构图\n艿艿：注意，这个图是自下向上看。哈哈哈~\nReactor 通信调度层：由一系列辅助类组成，包括 Reactor 线程 NioEventLoop 及其父类，NioSocketChannel 和 NioServerSocketChannel 等等。该层的职责就是监听网络的读写和连接操作，负责将网络层的数据读到内存缓冲区，然后触发各自网络事件，例如连接创建、连接激活、读事件、写事件等。将这些事件触发到 pipeline 中，由 pipeline 管理的职责链来进行后续的处理。\n职责链 ChannelPipeline：负责事件在职责链中的有序传播，以及负责动态地编排职责链。职责链可以选择监听和处理自己关心的事件，拦截处理和向后传播事件。\n业务逻辑编排层：业务逻辑编排层通常有两类，一类是纯粹的业务逻辑编排，一类是应用层协议插件，用于特定协议相关的会话和链路管理。由于应用层协议栈往往是开发一次到处运行，并且变动较小，故而将应用协议到 POJO 的转变和上层业务放到不同的 ChannelHandler 中，就可以实现协议层和业务逻辑层的隔离，实现架构层面的分层隔离。\n什么是 Reactor 模型？ 直接阅读 《精尽 Netty 源码解析 —— EventLoop（一）之 Reactor 模型》 一文。\n认真仔细读，这是一个高频面试题。\n请介绍 Netty 的线程模型？ 还是阅读 《精尽 Netty 源码解析 —— EventLoop（一）之 Reactor 模型》 一文。\n认真仔细读，这真的真的真的是一个高频面试题。\n什么是业务线程池？ 🦅 问题\n在 「什么是 Reactor 模型？」 问题中，无论是那种类型的 Reactor 模型，都需要在 Reactor 所在的线程中，进行读写操作。那么此时就会有一个问题，如果我们读取到数据，需要进行业务逻辑处理，并且这个业务逻辑需要对数据库、缓存等等进行操作，会有什么问题呢？假设这个数据库操作需要 5 ms ，那就意味着这个 Reactor 线程在这 5 ms 无法进行注册在这个 Reactor 的 Channel 进行读写操作。也就是说，多个 Channel 的所有读写操作都变成了串行。势必，这样的效率会非常非常非常的低。\n🦅 解决\n那么怎么解决呢？创建业务线程池，将读取到的数据，提交到业务线程池中进行处理。这样，Reactor 的 Channel 就不会被阻塞，而 Channel 的所有读写操作都变成了并行了。\n🦅 案例\n如果胖友熟悉 Dubbo 框架，就会发现 《Dubbo 用户指南 —— 线程模型》 。😈 认真读下，可以跟面试官吹一吹啦。\nTCP 粘包 / 拆包的原因？应该这么解决？ 🦅 概念\nTCP 是以流的方式来处理数据，所以会导致粘包 / 拆包。\n拆包：一个完整的包可能会被 TCP 拆分成多个包进行发送。\n粘包：也可能把小的封装成一个大的数据包发送。\n🦅 原因\n应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象。而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象。\n待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。\n以太网帧的 payload（净荷）大于 MTU（默认为 1500 字节）进行 IP 分片拆包。\n接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。\n🦅 解决\n在 Netty 中，提供了多个 Decoder 解析类，如下：\n① FixedLengthFrameDecoder ，基于固定长度消息进行粘包拆包处理的。\n② LengthFieldBasedFrameDecoder ，基于消息头指定消息长度进行粘包拆包处理的。\n③ LineBasedFrameDecoder ，基于换行来进行消息粘包拆包处理的。\n④ DelimiterBasedFrameDecoder ，基于指定消息边界方式进行粘包拆包处理的。\n实际上，上述四个 FrameDecoder 实现可以进行规整：\n① 是 ② 的特例，固定长度是消息头指定消息长度的一种形式。\n③ 是 ④ 的特例，换行是于指定消息边界方式的一种形式。\n感兴趣的胖友，可以看看如下两篇文章：\n《精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（一）Cumulator》\n《精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（二）FrameDecoder》\n了解哪几种序列化协议？ 🦅 概念\n序列化（编码），是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等。\n反序列化（解码），则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。\n🦅 选型\n在选择序列化协议的选择，主要考虑以下三个因素：\n序列化后的字节大小。更少的字节数，可以减少网络带宽、磁盘的占用。\n序列化的性能。对 CPU、内存资源占用情况。\n是否支持跨语言。例如，异构系统的对接和开发语言切换。\n🦅 方案\n如果对序列化工具了解不多的胖友，可能一看有这么多优缺点会比较懵逼，可以先记得有哪些序列化工具，然后在慢慢熟悉它们的优缺点。\n重点，还是知道【选型】的考虑点。\n【重点】Java 默认提供的序列化 无法跨语言；序列化后的字节大小太大；序列化的性能差。 【重点】XML 。 优点：人机可读性好，可指定元素或特性的名称。\n缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。\n适用场景：当做配置文件存储数据，实时数据转换。\n【重点】JSON ，是一种轻量级的数据交换格式。 优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好。与 XML 相比，其协议比较简单，解析速度比较快。\n缺点：数据的描述性比 XML 差、不适合性能要求为 ms 级别的情况、额外空间开销比较大。\n适用场景（可替代 XML ）：跨防火墙访问、可调式性要求高、基于Restful API 请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。\n【了解】Thrift ，不仅是序列化协议，还是一个 RPC 框架。 优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。\n缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如 HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。\n适用场景：分布式系统的 RPC 解决方案。\n【了解】Avro ，Hadoop 的一个子项目，解决了JSON的冗长和没有IDL的问题。 优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用 RPC、支持跨编程语言实现。\n缺点：对于习惯于静态类型语言的用户不直观。\n适用场景：在 Hadoop 中做 Hive、Pig 和 MapReduce 的持久化数据格式。\n【重点】Protobuf ，将数据结构以 .proto 文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO 对象和 Protobuf 相关的方法和属性。 优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。\n缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++、python。\n适用场景：对性能要求高的 RPC 调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化。\n其它 目前，阿里 RPC 框架 Dubbo 的可选序列化协议。\n目前，阿里 RPC 框架 Dubbo 的可选序列化协议。\n目前，阿里 RPC 框架 Dubbo 的默认序列化协议。\n目前，微博 RPC 框架 Motan 在使用它。\n【重点】Protostuff ，基于 Protobuf 协议，但不需要配置proto 文件，直接导包即可。\n【了解】Jboss Marshaling ，可以直接序列化 Java 类， 无须实 java.io.Serializable 接口。\n【了解】Message Pack ，一个高效的二进制序列化格式。\n【重点】Hessian ，采用二进制协议的轻量级 remoting on http 服务。\n【重要】kryo ，是一个快速高效的Java对象图形序列化框架，主要特点是性能、高效和易用。该项目用来序列化对象到文件、数据库或者网络。\n【重要】FST ，fast-serialization 是重新实现的 Java 快速对象序列化的开发包。序列化速度更快（2-10倍）、体积更小，而且兼容 JDK 原生的序列化。要求 JDK 1.7 支持。\nNetty 的零拷贝实现？ Netty 的零拷贝实现，是体现在多方面的，主要如下：\n【重点】Netty 的接收和发送 ByteBuffer 采用堆外直接内存 Direct Buffer 。 使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝；使用堆内内存会多了一次内存拷贝，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。\nNetty 创建的 ByteBuffer 类型，由 ChannelConfig 配置。而 ChannelConfig 配置的 ByteBufAllocator 默认创建 Direct Buffer 类型。\nCompositeByteBuf 类，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf ，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer 。 #addComponents(...) 方法，可将 header 与 body 合并为一个逻辑上的 ByteBuf 。这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的，即 CompositeByteBuf 只是逻辑上是一个整体。 通过 FileRegion 包装的 FileChannel 。 #tranferTo(...) 方法，实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel ，避免了传统通过循环 write 方式，导致的内存拷贝问题。 通过 wrap 方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer 等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。 原生的 NIO 存在 Epoll Bug 是什么？Netty 是怎么解决的？ 🦅 Java NIO Epoll BUG\nJava NIO Epoll 会导致 Selector 空轮询，最终导致 CPU 100% 。\n官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些而已，它并没有得到根本性解决。\n🦅 Netty 解决方案\n对 Selector 的 select 操作周期进行统计，每完成一次空的 select 操作进行一次计数，若在某个周期内连续发生 N 次空轮询，则判断触发了 Epoll 死循环 Bug 。\n艿艿：此处空的 select 操作的定义是，select 操作执行了 0 毫秒。\n此时，Netty 重建 Selector 来解决。判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从旧的 Selector 上取消注册，然后重新注册到新的 Selector 上，最后将原来的 Selector 关闭。\n什么是 Netty 空闲检测？ 在 Netty 中，提供了 IdleStateHandler 类，正如其名，空闲状态处理器，用于检测连接的读写是否处于空闲状态。如果是，则会触发 IdleStateEvent 。\nIdleStateHandler 目前提供三种类型的心跳检测，通过构造方法来设置。代码如下：\n1 2 3 4 5 6 7 8 9 // IdleStateHandler.java public IdleStateHandler( int readerIdleTimeSeconds, int writerIdleTimeSeconds, int allIdleTimeSeconds) { this(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds, TimeUnit.SECONDS); } readerIdleTimeSeconds 参数：为读超时时间，即测试端一定时间内未接受到被测试端消息。\nwriterIdleTimeSeconds 参数：为写超时时间，即测试端一定时间内向被测试端发送消息。\nallIdleTimeSeconds 参数：为读或写超时时间。\n另外，我们会在网络上看到类似《IdleStateHandler 心跳机制》这样标题的文章，实际上空闲检测和心跳机制是两件事。\n只是说，因为我们使用 IdleStateHandler 的目的，就是检测到连接处于空闲，通过心跳判断其是否还是有效的连接。\n虽然说，TCP 协议层提供了 Keeplive 机制，但是该机制默认的心跳时间是 2 小时，依赖操作系统实现不够灵活。因而，我们才在应用层上，自己实现心跳机制。\n具体的，我们来看看下面的问题 「Netty 如何实现重连？」 。\nNetty 如何实现重连？ 客户端，通过 IdleStateHandler 实现定时检测是否空闲，例如说 15 秒。\n如果空闲，则向服务端发起心跳。\n如果多次心跳失败，则关闭和服务端的连接，然后重新发起连接。\n服务端，通过 IdleStateHandler 实现定时检测客户端是否空闲，例如说 90 秒。\n如果检测到空闲，则关闭客户端。\n注意，如果接收到客户端的心跳请求，要反馈一个心跳响应给客户端。通过这样的方式，使客户端知道自己心跳成功。\n如下艿艿在自己的 TaroRPC 中提供的一个示例：\nNettyClient.java 中，设置 IdleStateHandler 和 ClientHeartbeatHandler。核心代码如下：\n1 2 3 4 // NettyHandler.java .addLast(\u0026#34;idleState\u0026#34;, new IdleStateHandler(TaroConstants.TRANSPORT\\_CLIENT\\_IDLE, TaroConstants.TRANSPORT\\_CLIENT\\_IDLE, 0, TimeUnit.MILLISECONDS)) .addLast(\u0026#34;heartbeat\u0026#34;, new ClientHeartbeatHandler()) NettyServer.java 中，设置 IdleStateHandler 和 ServerHeartbeatHandler。核心代码如下：\n1 2 3 4 // NettyServer.java .addLast(\u0026#34;idleState\u0026#34;, new IdleStateHandler(0, 0, TaroConstants.TRANSPORT\\_SERVER\\_IDLE, TimeUnit.MILLISECONDS)) .addLast(\u0026#34;heartbeat\u0026#34;, new ServerHeartbeatHandler()) ClientHeartbeatHandler.java 中，碰到空闲，则发起心跳。不过，如何重连，暂时没有实现。需要考虑，重新发起连接可能会失败的情况。具体的，可以看看 《一起学Netty（十四）之 Netty生产级的心跳和重连机制》 文章中的，ConnectionWatchdog 的代码。\nServerHeartbeatHandler.java 中，检测到客户端空闲，则直接关闭连接。\nNetty 自己实现的 ByteBuf 有什么优点？ 如下是 《Netty 实战》 对它的优点总结：\nA01. 它可以被用户自定义的缓冲区类型扩展\nA02. 通过内置的符合缓冲区类型实现了透明的零拷贝\nA03. 容量可以按需增长\nA04. 在读和写这两种模式之间切换不需要调用 #flip() 方法\nA05. 读和写使用了不同的索引\nA06. 支持方法的链式调用\nA07. 支持引用计数\nA08. 支持池化\n特别是第 A04 这点，相信很多胖友都被 NIO ByteBuffer 反人类的读模式和写模式给坑哭了。在 《精尽 Netty 源码分析 —— NIO 基础（三）之 Buffer》 中，我们也吐槽过了。😈 想要进一步深入的，可以看看 《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（一）简介》 。\nNetty 为什么要实现内存管理？ 🦅 老艿艿的理解\n在 Netty 中，IO 读写必定是非常频繁的操作，而考虑到更高效的网络传输性能，Direct ByteBuffer 必然是最合适的选择。但是 Direct ByteBuffer 的申请和释放是高成本的操作，那么进行池化管理，多次重用是比较有效的方式。但是，不同于一般于我们常见的对象池、连接池等池化的案例，ByteBuffer 是有大小一说。又但是，申请多大的 Direct ByteBuffer 进行池化又会是一个大问题，太大会浪费内存，太小又会出现频繁的扩容和内存复制！！！所以呢，就需要有一个合适的内存管理算法，解决高效分配内存的同时又解决内存碎片化的问题。\n🦅 官方的说法\nFROM 《Netty 学习笔记 —— Pooled buffer》\nNetty 4.x 增加了 Pooled Buffer，实现了高性能的 buffer 池，分配策略则是结合了 buddy allocation 和 slab allocation 的 jemalloc 变种，代码在io.netty.buffer.PoolArena 中。\n官方说提供了以下优势：\n频繁分配、释放 buffer 时减少了 GC 压力。\n在初始化新 buffer 时减少内存带宽消耗( 初始化时不可避免的要给buffer数组赋初始值 )。\n及时的释放 direct buffer 。\n🦅 hushi55 大佬的理解\nC/C++ 和 java 中有个围城，城里的想出来，城外的想进去！**\n这个围城就是自动内存管理！\nNetty 4 buffer 介绍\nNetty4 带来一个与众不同的特点是其 ByteBuf 的实现，相比之下，通过维护两个独立的读写指针， 要比 io.netty.buffer.ByteBuf 简单不少，也会更高效一些。不过，Netty 的 ByteBuf 带给我们的最大不同，就是他不再基于传统 JVM 的 GC 模式，相反，它采用了类似于 C++ 中的 malloc/free 的机制，需要开发人员来手动管理回收与释放。从手动内存管理上升到GC，是一个历史的巨大进步， 不过，在20年后，居然有曲线的回归到了手动内存管理模式，正印证了马克思哲学观： 社会总是在螺旋式前进的，没有永远的最好。\n① GC 内存管理分析\n的确，就内存管理而言，GC带给我们的价值是不言而喻的，不仅大大的降低了程序员的心智包袱， 而且，也极大的减少了内存管理带来的 Crash 困扰，为函数式编程（大量的临时对象）、脚本语言编程带来了春天。 并且，高效的GC算法也让大部分情况下程序可以有更高的执行效率。 不过，也有很多的情况，可能是手工内存管理更为合适的。譬如：\n对于类似于业务逻辑相对简单，譬如网络路由转发型应用（很多erlang应用其实是这种类型）， 但是 QPS 非常高，比如1M级，在这种情况下，在每次处理中即便产生1K的垃圾，都会导致频繁的GC产生。 在这种模式下，erlang 的按进程回收模式，或者是 C/C++ 的手工回收机制，效率更高。\nCache 型应用，由于对象的存在周期太长，GC 基本上就变得没有价值。\n所以，理论上，尴尬的GC实际上比较适合于处理介于这 2 者之间的情况： 对象分配的频繁程度相比数据处理的时间要少得多的，但又是相对短暂的， 典型的，对于OLTP型的服务，处理能力在 1K QPS 量级，每个请求的对象分配在 10K-50K 量级， 能够在 5-10s 的时间内进行一 次younger GC ，每次GC的时间可以控制在 10ms 水平上， 这类的应用，实在是太适合 GC 行的模式了，而且结合 Java 高效的分代 GC ，简直就是一个理想搭配。\n② 影响\nNetty 4 引入了手工内存的模式，我觉得这是一大创新，这种模式甚至于会延展， 应用到 Cache 应用中。实际上，结合 JVM 的诸多优秀特性，如果用 Java 来实现一个 Redis 型 Cache、 或者 In-memory SQL Engine，或者是一个 Mongo DB，我觉得相比 C/C++ 而言，都要更简单很多。 实际上，JVM 也已经提供了打通这种技术的机制，就是 Direct Memory 和 Unsafe 对象。 基于这个基础，我们可以像 C 语言一样直接操作内存。实际上，Netty4 的 ByteBuf 也是基于这个基础的。\n更多详细的内容，胖友可以看看 《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（一）简介》 。\nNetty 如何实心内存管理？ 这个题目，简单了解即可，如果深入，就要去看 《精尽 Netty 源码解析 —— Buffer》 相关的源码。而且，看完就忘记，比较难和复杂。\n当然，看懂那一刻，乐趣无穷，哈哈哈哈。\nNetty 内存管理机制，基于 Jemalloc 算法。\n首先会预申请一大块内存 Arena ，Arena 由许多 Chunk 组成，而每个 Chunk 默认由2048个page组成。\nChunk 通过 AVL 树的形式组织 Page ，每个叶子节点表示一个 Page ，而中间节点表示内存区域，节点自己记录它在整个 Arena 中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于 8k 的内存分配在 PoolChunkList 中，而 PoolSubpage 用于分配小于 8k 的内存，它会把一个 page 分割成多段，进行内存分配。\n什么是 Netty 的内存泄露检测？是如何进行实现的？ 艿艿：这是一道比较复杂的面试题，可以挑战一下。\n推荐阅读如下两篇文章：\n《Netty 之有效规避内存泄漏》 从原理层面解释。\n《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》 从源码层面解读。\n另外，Netty 的内存泄露检测的实现，是对 WeakReference 和 ReferenceQueue 很好的学习。之前很多胖友在看了 《Java 中的四种引用类型》 之后，是不太理解 Java 的四种引用的具体使用场景，这不就来了么。\n","date":"2023-05-04T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/netty%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"netty面试题"},{"content":"精尽 Netty 源码分析 —— NIO 基础（二）之 Channel\n概述 在 Java NIO 中，基本上所有的 IO 操作都是从 Channel 开始。数据可以从 Channel 读取到 Buffer 中，也可以从 Buffer 写到 Channel 中。如下图所示： Buffer \u0026lt;=\u0026gt; Channel Buffer \u0026lt;=\u0026gt; Channel\nNIO Channel 对比 Java Stream NIO Channel 类似 Java Stream ，但又有几点不同： 对于同一个 Channel ，我们可以从它读取数据，也可以向它写入数据。而对于同一个 Stream ，通畅要么只能读，要么只能写，二选一( 有些文章也描述成“单向”，也是这个意思 )。 Channel 可以非阻塞的读写 IO 操作，而 Stream 只能阻塞的读写 IO 操作。 Channel 必须配合 Buffer 使用，总是先读取到一个 Buffer 中，又或者是向一个 Buffer 写入。也就是说，我们无法绕过 Buffer ，直接向 Channel 写入数据。 3. Channel 的实现 Channel 在 Java 中，作为一个接口，java.nio.channels.Channel ，定义了 IO 操作的连接与关闭。代码如下：\npublic interface Channel extends Closeable {\n/**\r* 判断此通道是否处于打开状态。 */\rpublic boolean isOpen();\r/**\r*关闭此通道。\r*/\rpublic void close() throws IOException;\r} Channel 有非常多的实现类，最为重要的四个 Channel 实现类如下：\nSocketChannel ：一个客户端用来发起 TCP 的 Channel 。 ServerSocketChannel ：一个服务端用来监听新进来的连接的 TCP 的 Channel 。对于每一个新进来的连接，都会创建一个对应的 SocketChannel 。 DatagramChannel ：通过 UDP 读写数据。 FileChannel ：从文件中，读写数据。 老艿艿：因为 《Java NIO 系列教程》 对上述的 Channel 解释的非常不错，我就直接引用啦。\n我们在使用 Netty 时，主要使用 TCP 协议，所以胖友可以只看 「3.2 SocketChannel」 和 「3.1 ServerSocketChannel」 。\n3.1 ServerSocketChannel 《Java NIO系列教程（九） ServerSocketChannel》\n3.2 SocketChannel 《Java NIO 系列教程（八） SocketChannel》\n3.3 DatagramChannel 《Java NIO系列教程（十） Java NIO DatagramChannel》\n3.4 FileChannel 《Java NIO系列教程（七） FileChannel》\n","date":"2023-05-04T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/","title":"netty源码分析二"},{"content":"1. 概述 一个 Buffer ，本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。通过将这块内存封装成 NIO Buffer 对象，并提供了一组常用的方法，方便我们对该块内存的读写。\nBuffer 在 java.nio 包中实现，被定义成抽象类，从而实现一组常用的方法。整体类图如下：\n类图\n我们可以将 Buffer 理解为一个数组的封装，例如 IntBuffer、CharBuffer、ByteBuffer 等分别对应 int[]、char[]、byte[] 等。\nMappedByteBuffer 用于实现内存映射文件，不是本文关注的重点。因此，感兴趣的胖友，可以自己 Google 了解，还是蛮有趣的。\n2. 基本属性 Buffer 中有 4 个非常重要的属性：capacity、limit、position、mark 。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public abstract class Buffer { // Invariants: mark \u0026lt;= position \u0026lt;= limit \u0026lt;= capacity private int mark = -1; private int position = 0; private int limit; private int capacity; // Used only by direct buffers // NOTE: hoisted here for speed in JNI GetDirectBufferAddress long address; Buffer(int mark, int pos, int lim, int cap) { // package-private if (cap \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Negative capacity: \u0026#34; \\+ cap); this.capacity = cap; limit(lim); position(pos); if (mark \u0026gt;= 0) { if (mark \u0026gt; pos) throw new IllegalArgumentException(\u0026#34;mark \u0026gt; position: (\u0026#34; \\+ mark + \u0026#34; \\\u0026gt; \u0026#34; \\+ pos + \u0026#34;)\u0026#34;); this.mark = mark; } } // ... 省略具体方法的代码 } capacity 属性，容量，Buffer 能容纳的数据元素的最大值。这一容量在 Buffer 创建时被赋值，并且永远不能被修改。\nBuffer 分成写模式和读模式两种情况。如下图所示：写模式 v.s. 读模式\n从图中，我们可以看到，两种模式下，position 和 limit 属性分别代表不同的含义。下面，我们来分别看看。\nposition 属性，位置，初始值为 0 。\n写模式下，每往 Buffer 中写入一个值，position 就自动加 1 ，代表下一次的写入位置。\n读模式下，每从 Buffer 中读取一个值，position 就自动加 1 ，代表下一次的读取位置。( 和写模式类似 )\nlimit 属性，上限。\n写模式下，代表最大能写入的数据上限位置，这个时候 limit 等于 capacity 。\n读模式下，在 Buffer 完成所有数据写入后，通过调用 #flip() 方法，切换到读模式。此时，limit 等于 Buffer 中实际的数据大小。因为 Buffer 不一定被写满，所以不能使用 capacity 作为实际的数据大小。\nmark 属性，标记，通过 #mark() 方法，记录当前 position ；通过 reset() 方法，恢复 position 为标记。\n写模式下，标记上一次写位置。\n读模式下，标记上一次读位置。\n从代码注释上，我们可以看到，四个属性总是遵循如下大小关系：\n1 mark \u0026lt;= position \u0026lt;= limit \u0026lt;= capacity 写到此处，忍不住吐槽了下，Buffer 的读模式和写模式，我认为是有一点“糟糕”。相信大多数人在理解的时候，都会开始一脸懵逼的状态。相比较来说，Netty 的 ByteBuf 就优雅的非常多，基本属性设计如下：\n1 0 \u0026lt;= readerIndex \u0026lt;= writerIndex \u0026lt;= capacity 通过 readerIndex 和 writerIndex 两个属性，避免出现读模式和写模式的切换。 3. 创建 Buffer ① 每个 Buffer 实现类，都提供了 #allocate(int capacity) 静态方法，帮助我们快速实例化一个 Buffer 对象。以 ByteBuffer 举例子，代码如下：\n1 2 3 4 5 6 // ByteBuffer.java public static ByteBuffer allocate(int capacity) { if (capacity \u0026lt; 0) throw new IllegalArgumentException(); return new HeapByteBuffer(capacity, capacity); } ByteBuffer 实际是个抽象类，返回的是它的基于堆内( Non-Direct )内存的实现类 HeapByteBuffer 的对象。 ② 每个 Buffer 实现类，都提供了 #wrap(array) 静态方法，帮助我们将其对应的数组包装成一个 Buffer 对象。还是以 ByteBuffer 举例子，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // ByteBuffer.java public static ByteBuffer wrap(byte\\[\\] array, int offset, int length){ try { return new HeapByteBuffer(array, offset, length); } catch (IllegalArgumentException x) { throw new IndexOutOfBoundsException(); } } public static ByteBuffer wrap(byte\\[\\] array) { return wrap(array, 0, array.length); } 和 #allocate(int capacity) 静态方法一样，返回的也是 HeapByteBuffer 的对象。 ③ 每个 Buffer 实现类，都提供了 #allocateDirect(int capacity) 静态方法，帮助我们快速实例化一个 Buffer 对象。以 ByteBuffer 举例子，代码如下：\n1 2 3 4 // ByteBuffer.java public static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } 和 #allocate(int capacity) 静态方法不一样，返回的是它的基于堆外( Direct )内存的实现类 DirectByteBuffer 的对象。 3.1 关于 Direct Buffer 和 Non-Direct Buffer 的区别 FROM 《Java NIO 的前生今世 之三 NIO Buffer 详解》\nDirect Buffer:\n所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)\n因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)\n申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.\n使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.\nNon-Direct Buffer:\n直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.\n因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低.\n笔者之前研究 JVM 内存时，也整理过一个脑图，感兴趣的胖友可以下载：传送门 。\n4. 向 Buffer 写入数据 每个 Buffer 实现类，都提供了 #put(...) 方法，向 Buffer 写入数据。以 ByteBuffer 举例子，代码如下：\n1 2 3 4 5 6 7 // 写入 byte public abstract ByteBuffer put(byte b); public abstract ByteBuffer put(int index, byte b); // 写入 byte 数组 public final ByteBuffer put(byte\\[\\] src) { ... } public ByteBuffer put(byte\\[\\] src, int offset, int length) {...} // ... 省略，还有其他 put 方法 对于 Buffer 来说，有一个非常重要的操作就是，我们要讲来自 Channel 的数据写入到 Buffer 中。在系统层面上，这个操作我们称为读操作，因为数据是从外部( 文件或者网络等 )读取到内存中。示例如下：\n1 int num = channel.read(buffer); 上述方法会返回从 Channel 中写入到 Buffer 的数据大小。对应方法的代码如下：\n1 2 3 4 5 public interface ReadableByteChannel extends Channel { public int read(ByteBuffer dst) throws IOException; } 注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。\n5. 从 Buffer 读取数据 每个 Buffer 实现类，都提供了 #get(...) 方法，从 Buffer 读取数据。以 ByteBuffer 举例子，代码如下：\n1 2 3 4 5 6 7 // 读取 byte public abstract byte get(); public abstract byte get(int index); // 读取 byte 数组 public ByteBuffer get(byte\\[\\] dst, int offset, int length) {...} public ByteBuffer get(byte\\[\\] dst) {...} // ... 省略，还有其他 get 方法 对于 Buffer 来说，还有一个非常重要的操作就是，我们要讲来向 Channel 的写入 Buffer 中的数据。在系统层面上，这个操作我们称为写操作，因为数据是从内存中写入到外部( 文件或者网络等 )。示例如下：\n1 int num = channel.write(buffer); 上述方法会返回向 Channel 中写入 Buffer 的数据大小。对应方法的代码如下：\n1 2 3 4 5 public interface WritableByteChannel extends Channel { public int write(ByteBuffer src) throws IOException; } 6. rewind() v.s. flip() v.s. clear() 6.1 flip 如果要读取 Buffer 中的数据，需要切换模式，从写模式切换到读模式。对应的为 #flip() 方法，代码如下：\n1 2 3 4 5 6 public final Buffer flip() { limit = position; // 设置读取上限 position = 0; // 重置 position mark = -1; // 清空 mark return this; } 使用示例，代码如下：\n1 2 3 4 buf.put(magic); // Prepend header in.read(buf); // Read data into rest of buffer buf.flip(); // Flip buffer channel.write(buf); // Write header + data to channel 6.2 rewind #rewind() 方法，可以重置 position 的值为 0 。因此，我们可以重新读取和写入 Buffer 了。\n大多数情况下，该方法主要针对于读模式，所以可以翻译为“倒带”。也就是说，和我们当年的磁带倒回去是一个意思。代码如下：\n1 2 3 4 5 public final Buffer rewind() { position = 0; // 重置 position mark = -1; // 清空 mark return this; } 从代码上，和 #flip() 相比，非常类似，除了少了第一行的 limit = position 的代码块。 使用示例，代码如下：\n1 2 3 channel.write(buf); // Write remaining data buf.rewind(); // Rewind buffer buf.get(array); // Copy data into array 6.3 clear #clear() 方法，可以“重置” Buffer 的数据。因此，我们可以重新读取和写入 Buffer 了。\n大多数情况下，该方法主要针对于写模式。代码如下：\n1 2 3 4 5 6 public final Buffer clear() { position = 0; // 重置 position limit = capacity; // 恢复 limit 为 capacity mark = -1; // 清空 mark return this; } 从源码上，我们可以看出，Buffer 的数据实际并未清理掉，所以使用时需要注意。\n读模式下，尽量不要调用 #clear() 方法，因为 limit 可能会被错误的赋值为 capacity 。相比来说，调用 #rewind() 更合理，如果有重读的需求。\n使用示例，代码如下：\n1 2 buf.clear(); // Prepare buffer for reading in.read(buf); // Read data 7. mark() 搭配 reset() 7.1 mark #mark() 方法，保存当前的 position 到 mark 中。代码如下：\n1 2 3 4 public final Buffer mark() { mark = position; return this; } 7.2 reset #reset() 方法，恢复当前的 postion 为 mark 。代码如下：\n1 2 3 4 5 6 7 public final Buffer reset() { int m = mark; if (m \u0026lt; 0) throw new InvalidMarkException(); position = m; return this; } 8. 其它方法 Buffer 中还有其它方法，比较简单，所以胖友自己研究噢。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // ========== capacity ========== public final int capacity() { return capacity; } // ========== position ========== public final int position() { return position; } public final Buffer position(int newPosition) { if ((newPosition \u0026gt; limit) || (newPosition \u0026lt; 0)) throw new IllegalArgumentException(); position = newPosition; if (mark \u0026gt; position) mark = -1; return this; } // ========== limit ========== public final int limit() { return limit; } public final Buffer limit(int newLimit) { if ((newLimit \u0026gt; capacity) || (newLimit \u0026lt; 0)) throw new IllegalArgumentException(); limit = newLimit; if (position \u0026gt; limit) position = limit; if (mark \u0026gt; limit) mark = -1; return this; } // ========== mark ========== final int markValue() { // package-private return mark; } final void discardMark() { // package-private mark = -1; } // ========== 数组相关 ========== public final int remaining() { return limit - position; } public final boolean hasRemaining() { return position \u0026lt; limit; } public abstract boolean hasArray(); public abstract Object array(); public abstract int arrayOffset(); public abstract boolean isDirect(); // ========== 下一个读 / 写 position ========== final int nextGetIndex() { // package-private if (position \u0026gt;= limit) throw new BufferUnderflowException(); return position++; } final int nextGetIndex(int nb) { // package-private if (limit - position \u0026lt; nb) throw new BufferUnderflowException(); int p = position; position += nb; return p; } final int nextPutIndex() { // package-private if (position \u0026gt;= limit) throw new BufferOverflowException(); return position++; } final int nextPutIndex(int nb) { // package-private if (limit - position \u0026lt; nb) throw new BufferOverflowException(); int p = position; position += nb; return p; } final int checkIndex(int i) { // package-private if ((i \u0026lt; 0) || (i \u0026gt;= limit)) throw new IndexOutOfBoundsException(); return i; } final int checkIndex(int i, int nb) { // package-private if ((i \u0026lt; 0) || (nb \u0026gt; limit - i)) throw new IndexOutOfBoundsException(); return i; } // ========== 其它方法 ========== final void truncate() { // package-private mark = -1; position = 0; limit = 0; capacity = 0; } static void checkBounds(int off, int len, int size) { // package-private if ((off | len | (off + len) | (size - (off + len))) \u0026lt; 0) throw new IndexOutOfBoundsException(); } ","date":"2023-05-04T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/","title":"netty源码分析三"},{"content":"Selector ， 一般称为选择器。它是 Java NIO 核心组件中的一个，用于轮询一个或多个 NIO Channel 的状态是否处于可读、可写。如此，一个线程就可以管理多个 Channel ，也就说可以管理多个网络连接。也因此，Selector 也被称为多路复用器。\n那么 Selector 是如何轮询的呢？\n首先，需要将 Channel 注册到 Selector 中，这样 Selector 才知道哪些 Channel 是它需要管理的。\n之后，Selector 会不断地轮询注册在其上的 Channel 。如果某个 Channel 上面发生了读或者写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。\n下图是一个 Selector 管理三个 Channel 的示例：\n2. 优缺点 ① 优点\n使用一个线程能够处理多个 Channel 的优点是，只需要更少的线程来处理 Channel 。事实上，可以使用一个线程处理所有的 Channel 。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源( 例如 CPU、内存 )。因此，使用的线程越少越好。\n② 缺点\n因为在一个线程中使用了多个 Channel ，因此会造成每个 Channel 处理效率的降低。\n当然，Netty 在设计实现上，通过 n 个线程处理多个 Channel ，从而很好的解决了这样的缺点。其中，n 的指的是有限的线程数，默认情况下为 CPU * 2 。\n3. Selector 类图 Selector 在 java.nio 包中，被定义成抽象类，整体实现类图如下：\nSelector 的实现不是本文的重点，感兴趣的胖友可以看看占小狼的 《深入浅出NIO之Selector实现原理》 。 3. 创建 Selector 通过 #open() 方法，我们可以创建一个 Selector 对象。代码如下：\n1 Selector selector = Selector.open(); 4. 注册 Chanel 到 Selector 中 为了让 Selector 能够管理 Channel ，我们需要将 Channel 注册到 Selector 中。代码如下：\n1 2 channel.configureBlocking(false); // \u0026lt;1\u0026gt; SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 注意，如果一个 Channel 要注册到 Selector 中，那么该 Channel 必须是非阻塞，所以 \u0026lt;1\u0026gt; 处的 channel.configureBlocking(false); 代码块。也因此，FileChannel 是不能够注册到 Channel 中的，因为它是阻塞的。\n在 #register(Selector selector, int interestSet) 方法的第二个参数，表示一个“interest 集合”，意思是通过 Selector 监听 Channel 时，对哪些( 可以是多个 )事件感兴趣。可以监听四种不同类型的事件：\nChannel 触发了一个事件，意思是该事件已经就绪：\nConnect ：连接完成事件( TCP 连接 )，仅适用于客户端，对应 SelectionKey.OP_CONNECT 。\nAccept ：接受新连接事件，仅适用于服务端，对应 SelectionKey.OP_ACCEPT 。\nRead ：读事件，适用于两端，对应 SelectionKey.OP_READ ，表示 Buffer 可读。\nWrite ：写时间，适用于两端，对应 SelectionKey.OP_WRITE ，表示 Buffer 可写。\n一个 Client Channel Channel 成功连接到另一个服务器，称为“连接就绪”。\n一个 Server Socket Channel 准备好接收新进入的连接，称为“接收就绪”。\n一个有数据可读的 Channel ，可以说是“读就绪”。\n一个等待写数据的 Channel ，可以说是“写就绪”。\n因为 Selector 可以对 Channel 的多个事件感兴趣，所以在我们想要注册 Channel 的多个事件到 Selector 中时，可以使用或运算 | 来组合多个事件。示例代码如下：\n1 int interestSet = SelectionKey.OP\\_READ | SelectionKey.OP\\_WRITE; 实际使用时，我们会有改变 Selector 对 Channel 感兴趣的事件集合，可以通过再次调用 #register(Selector selector, int interestSet) 方法来进行变更。示例代码如下：\n1 2 channel.register(selector, SelectionKey.OP_READ); channel.register(selector, SelectionKey.OP\\_READ | SelectionKey.OP\\_WRITE); 初始时，Selector 仅对 Channel 的 SelectionKey.OP_READ 事件感兴趣。\n修改后，Selector 仅对 Channel 的 SelectionKey.OP_READ 和 SelectionKey.OP_WRITE) 事件都感兴趣。\n5. SelectionKey 类 上一小节, 当我们调用 Channel 的 #register(...) 方法，向 Selector 注册一个 Channel 后，会返回一个 SelectionKey 对象。那么 SelectionKey 是什么呢？SelectionKey 在 java.nio.channels 包下，被定义成一个抽象类，表示一个 Channel 和一个 Selector 的注册关系，包含如下内容：\ninterest set ：感兴趣的事件集合。\nready set ：就绪的事件集合。\nChannel\nSelector\nattachment ：_可选的_附加对象。\n5.1 interest set 通过调用 #interestOps() 方法，返回感兴趣的事件集合。示例代码如下：\n1 2 3 4 5 6 7 int interestSet = selectionKey.interestOps(); // 判断对哪些事件感兴趣 boolean isInterestedInAccept = interestSet \u0026amp; SelectionKey.OP_ACCEPT != 0; boolean isInterestedInConnect = interestSet \u0026amp; SelectionKey.OP_CONNECT != 0; boolean isInterestedInRead = interestSet \u0026amp; SelectionKey.OP_READ != 0; boolean isInterestedInWrite = interestSet \u0026amp; SelectionKey.OP_WRITE != 0; 其中每个事件 Key 在 SelectionKey 中枚举，通过位( bit ) 表示。代码如下：\n1 2 3 4 5 6 // SelectionKey.java public static final int OP_READ = 1 \u0026lt;\u0026lt; 0; public static final int OP_WRITE = 1 \u0026lt;\u0026lt; 2; public static final int OP_CONNECT = 1 \u0026lt;\u0026lt; 3; public static final int OP_ACCEPT = 1 \u0026lt;\u0026lt; 4; 所以，在上述示例的后半段的代码，可以通过与运算 \u0026amp; 来判断是否对指定事件感兴趣。\n5.2 ready set 通过调用 #readyOps() 方法，返回就绪的事件集合。示例代码如下：\n1 2 3 4 5 6 7 int readySet = selectionKey.readyOps(); // 判断哪些事件已就绪 selectionKey.isAcceptable(); selectionKey.isConnectable(); selectionKey.isReadable(); selectionKey.isWritable(); 相比 interest set 来说，ready set 已经内置了判断事件的方法。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // SelectionKey.java public final boolean isReadable() { return (readyOps() \u0026amp; OP_READ) != 0; } public final boolean isWritable() { return (readyOps() \u0026amp; OP_WRITE) != 0; } public final boolean isConnectable() { return (readyOps() \u0026amp; OP_CONNECT) != 0; } public final boolean isAcceptable() { return (readyOps() \u0026amp; OP_ACCEPT) != 0; } 5.3 attachment 通过调用 #attach(Object ob) 方法，可以向 SelectionKey 添加附加对象；通过调用 #attachment() 方法，可以获得 SelectionKey 获得附加对象。示例代码如下：\n1 2 selectionKey.attach(theObject); Object attachedObj = selectionKey.attachment(); 又获得在注册时，直接添加附加对象。示例代码如下：\n1 SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); 6. 通过 Selector 选择 Channel 在 Selector 中，提供三种类型的选择( select )方法，返回当前有感兴趣事件准备就绪的 Channel 数量：\n1 2 3 4 5 6 7 8 9 10 // Selector.java // 阻塞到至少有一个 Channel 在你注册的事件上就绪了。 public abstract int select() throws IOException; // 在 `#select()` 方法的基础上，增加超时机制。 public abstract int select(long timeout) throws IOException; // 和 `#select()` 方法不同，立即返回数量，而不阻塞。 public abstract int selectNow() throws IOException; 有一点非常需要注意：select 方法返回的 int 值，表示有多少 Channel 已经就绪。亦即，自上次调用 select 方法后有多少 Channel 变成就绪状态。如果调用 select 方法，因为有一个 Channel 变成就绪状态则返回了 1 ；若再次调用 select 方法，如果另一个 Channel 就绪了，它会再次返回1。如果对第一个就绪的 Channel 没有做任何操作，现在就有两个就绪的 Channel ，但在每次 select 方法调用之间，只有一个 Channel 就绪了，所以才返回 1。 7. 获取可操作的 Channel 一旦调用了 select 方法，并且返回值表明有一个或更多个 Channel 就绪了，然后可以通过调用Selector 的 #selectedKeys() 方法，访问“已选择键集( selected key set )”中的就绪 Channel 。示例代码所示：\n1 Set selectedKeys = selector.selectedKeys(); 注意，当有新增就绪的 Channel ，需要先调用 select 方法，才会添加到“已选择键集( selected key set )”中。否则，我们直接调用 #selectedKeys() 方法，是无法获得它们对应的 SelectionKey 们。 8. 唤醒 Selector 选择 某个线程调用 #select() 方法后，发生阻塞了，即使没有通道已经就绪，也有办法让其从 #select() 方法返回。\n只要让其它线程在第一个线程调用 select() 方法的那个 Selector 对象上，调用该 Selector 的 #wakeup() 方法，进行唤醒该 Selector 即可。\n那么，阻塞在 #select()方法上的线程，会立马返回。\nSelector 的 #select(long timeout) 方法，若未超时的情况下，也可以满足上述方式。\n注意，如果有其它线程调用了 #wakeup() 方法，但当前没有线程阻塞在 #select() 方法上，下个调用 #select() 方法的线程会立即被唤醒。😈 有点神奇。\n9. 关闭 Selector 当我们不再使用 Selector 时，可以调用 Selector 的 #close() 方法，将它进行关闭。\nSelector 相关的所有 SelectionKey 都会失效。\nSelector 相关的所有 Channel 并不会关闭。\n注意，此时若有线程阻塞在 #select() 方法上，也会被唤醒返回。\n10. 简单 Selector 示例 如下是一个简单的 Selector 示例，创建一个 Selector ，并将一个 Channel注册到这个 Selector上( Channel 的初始化过程略去 )，然后持续轮询这个 Selector 的四种事件( 接受，连接，读，写 )是否就绪。代码如下：\n老艿艿：本代码取自 《Java NIO系列教程（六） Selector》 提供的示例，实际生产环境下并非这样的代码。🙂 最佳的实践，我们将在 Netty 中看到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 创建 Selector Selector selector = Selector.open(); // 注册 Channel 到 Selector 中 channel.configureBlocking(false); SelectionKey key = channel.register(selector, SelectionKey.OP_READ); while (true) { // 通过 Selector 选择 Channel int readyChannels = selector.select(); if (readyChannels == 0) { continue; } // 获得可操作的 Channel Set selectedKeys = selector.selectedKeys(); // 遍历 SelectionKey 数组 Iterator\u0026lt;SelectionKey\u0026gt; keyIterator = selectedKeys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } // 移除 keyIterator.remove(); // \u0026lt;1\u0026gt; } } 注意, 在每次迭代时, 我们都调用 keyIterator.remove() 代码块，将这个 key 从迭代器中删除。\n因为 #select() 方法仅仅是简单地将就绪的 Channel 对应的 SelectionKey 放到 selected keys 集合中。\n因此，如果我们从 selected keys 集合中，获取到一个 key ，但是没有将它删除，那么下一次 #select 时, 这个 SelectionKey 还在 selectedKeys 中.\n","date":"2023-05-04T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B/","title":"netty源码分析四"},{"content":"在前面的四篇文章，我们已经对 NIO 的概念已经有了一定的了解。当然，胖友也可能和我一样，已经被一堆概念烦死了。\n那么本文，我们撸起袖子，就是干代码，不瞎比比了。\n当然，下面更多的是提供一个 NIO 示例。真正生产级的 NIO 代码，建议胖友重新写，或者直接使用 Netty 。\n代码仓库在 example/yunai/nio 目录下。一共 3 个类：\nNioServer ：NIO 服务端。\nNioClient ：NIO 客户端。\nCodecUtil ：消息编解码工具类。\n2. 服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 1: public class NioServer { 2: 3: private ServerSocketChannel serverSocketChannel; 4: private Selector selector; 5: 6: public NioServer() throws IOException { 7: // 打开 Server Socket Channel 8: serverSocketChannel = ServerSocketChannel.open(); 9: // 配置为非阻塞 10: serverSocketChannel.configureBlocking(false); 11: // 绑定 Server port 12: serverSocketChannel.socket().bind(new InetSocketAddress(8080)); 13: // 创建 Selector 14: selector = Selector.open(); 15: // 注册 Server Socket Channel 到 Selector 16: serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); 17: System.out.println(\u0026#34;Server 启动完成\u0026#34;); 18: 19: handleKeys(); 20: } 21: 22: private void handleKeys() throws IOException { 23: while (true) { 24: // 通过 Selector 选择 Channel 25: int selectNums = selector.select(30 \\* 1000L); 26: if (selectNums == 0) { 27: continue; 28: } 29: System.out.println(\u0026#34;选择 Channel 数量：\u0026#34; \\+ selectNums); 30: 31: // 遍历可选择的 Channel 的 SelectionKey 集合 32: Iterator\u0026lt;SelectionKey\u0026gt; iterator = selector.selectedKeys().iterator(); 33: while (iterator.hasNext()) { 34: SelectionKey key = iterator.next(); 35: iterator.remove(); // 移除下面要处理的 SelectionKey 36: if (!key.isValid()) { // 忽略无效的 SelectionKey 37: continue; 38: } 39: 40: handleKey(key); 41: } 42: } 43: } 44: 45: private void handleKey(SelectionKey key) throws IOException { 46: // 接受连接就绪 47: if (key.isAcceptable()) { 48: handleAcceptableKey(key); 49: } 50: // 读就绪 51: if (key.isReadable()) { 52: handleReadableKey(key); 53: } 54: // 写就绪 55: if (key.isWritable()) { 56: handleWritableKey(key); 57: } 58: } 59: 60: private void handleAcceptableKey(SelectionKey key) throws IOException { 61: // 接受 Client Socket Channel 62: SocketChannel clientSocketChannel = ((ServerSocketChannel) key.channel()).accept(); 63: // 配置为非阻塞 64: clientSocketChannel.configureBlocking(false); 65: // log 66: System.out.println(\u0026#34;接受新的 Channel\u0026#34;); 67: // 注册 Client Socket Channel 到 Selector 68: clientSocketChannel.register(selector, SelectionKey.OP_READ, new ArrayList\u0026lt;String\u0026gt;()); 69: } 70: 71: private void handleReadableKey(SelectionKey key) throws IOException { 72: // Client Socket Channel 73: SocketChannel clientSocketChannel = (SocketChannel) key.channel(); 74: // 读取数据 75: ByteBuffer readBuffer = CodecUtil.read(clientSocketChannel); 76: // 处理连接已经断开的情况 77: if (readBuffer == null) { 78: System.out.println(\u0026#34;断开 Channel\u0026#34;); 79: clientSocketChannel.register(selector, 0); 80: return; 81: } 82: // 打印数据 83: if (readBuffer.position() \u0026gt; 0) { 84: String content = CodecUtil.newString(readBuffer); 85: System.out.println(\u0026#34;读取数据：\u0026#34; \\+ content); 86: 87: // 添加到响应队列 88: List\u0026lt;String\u0026gt; responseQueue = (ArrayList\u0026lt;String\u0026gt;) key.attachment(); 89: responseQueue.add(\u0026#34;响应：\u0026#34; \\+ content); 90: // 注册 Client Socket Channel 到 Selector 91: clientSocketChannel.register(selector, SelectionKey.OP_WRITE, key.attachment()); 92: } 93: } 94: 95: @SuppressWarnings(\u0026#34;Duplicates\u0026#34;) 96: private void handleWritableKey(SelectionKey key) throws ClosedChannelException { 97: // Client Socket Channel 98: SocketChannel clientSocketChannel = (SocketChannel) key.channel(); 99: 100: // 遍历响应队列 101: List\u0026lt;String\u0026gt; responseQueue = (ArrayList\u0026lt;String\u0026gt;) key.attachment(); 102: for (String content : responseQueue) { 103: // 打印数据 104: System.out.println(\u0026#34;写入数据：\u0026#34; \\+ content); 105: // 返回 106: CodecUtil.write(clientSocketChannel, content); 107: } 108: responseQueue.clear(); 109: 110: // 注册 Client Socket Channel 到 Selector 111: clientSocketChannel.register(selector, SelectionKey.OP_READ, responseQueue); 112: } 113: 114: public static void main(String\\[\\] args) throws IOException { 115: NioServer server = new NioServer(); 116: } 117: 118: } 整块代码我们可以分成 3 部分：\n构造方法：初始化 NIO 服务端。\n#handleKeys() 方法：基于 Selector 处理 IO 操作。\n#main(String[] args) 方法：创建 NIO 服务端。\n下面，我们逐小节来分享。\n2.1 构造方法 对应【第 3 至 20 行】的代码。\nserverSocketChannel 属性，服务端的 ServerSocketChannel ，在【第 7 至 12 行】的代码进行初始化，重点是此处启动了服务端，并监听指定端口( 此处为 8080 )。\nselector 属性，选择器，在【第 14 至 16 行】的代码进行初始化，重点是此处将 serverSocketChannel 到 selector 中，并对 SelectionKey.OP_ACCEPT 事件感兴趣。这样子，在客户端连接服务端时，我们就可以处理该 IO 事件。\n第 19 行：调用 #handleKeys() 方法，基于 Selector 处理 IO 事件。\n2.2 handleKeys 对应【第 22 至 43 行】的代码。\n第 23 行：死循环。本文的示例，不考虑服务端关闭的逻辑。\n第 24 至 29 行：调用 Selector#select(long timeout) 方法，每 30 秒阻塞等待有就绪的 IO 事件。此处的 30 秒为笔者随意写的，实际也可以改成其他超时时间，或者 Selector#select() 方法。当不存在就绪的 IO 事件，直接 continue ，继续下一次阻塞等待。\n第 32 行：调用 Selector#selectedKeys() 方法，获得有就绪的 IO 事件( 也可以称为“选择的” ) Channel 对应的 SelectionKey 集合。\n第 33 行 至 35 行：遍历 iterator ，进行逐个 SelectionKey 处理。重点注意下，处理完需要进行移除，具体原因，在 《精尽 Netty 源码分析 —— NIO 基础（四）之 Selector》「10. 简单 Selector 示例」 有详细解析。\n第 36 至 38 行：在遍历的过程中，可能该 SelectionKey 已经失效，直接 continue ，不进行处理。\n第 40 行：调用 #handleKey() 方法，逐个 SelectionKey 处理。\n2.2.1 handleKey 对应【第 45 至 58 行】的代码。\n通过调用 SelectionKey 的 #isAcceptable()、#isReadable()、#isWritable() 方法，分别判断 Channel 是接受连接就绪，还是读就绪，或是写就绪，并调用相应的 #handleXXXX(SelectionKey key) 方法，处理对应的 IO 事件。\n因为 SelectionKey 可以同时对一个 Channel 的多个事件感兴趣，所以此处的代码都是 if 判断，而不是 if else 判断。😈 虽然，考虑到让示例更简单，本文的并未编写同时对一个 Channel 的多个事件感兴趣，后续我们会在 Netty 的源码解析中看到。\nSelectionKey.OP_CONNECT 使用在客户端中，所以此处不需要做相应的判断和处理。\n2.2.2 handleAcceptableKey 对应【第 60 至 69 行】的代码。\n第 62 行：调用 ServerSocketChannel#accept() 方法，获得连接的客户端的 SocketChannel 。\n第 64 行：配置客户端的 SocketChannel 为非阻塞，否则无法使用 Selector 。\n第 66 行：打印日志，方便调试。实际场景下，使用 Logger 而不要使用 System.out 进行输出。\n第 68 行：注册客户端的 SocketChannel 到 selector 中，并对 SelectionKey.OP_READ 事件感兴趣。这样子，在客户端发送消息( 数据 )到服务端时，我们就可以处理该 IO 事件。\n为什么不对 SelectionKey.OP_WRITE 事件感兴趣呢？因为这个时候，服务端一般不会主动向客户端发送消息，所以不需要对 SelectionKey.OP_WRITE 事件感兴趣。\n细心的胖友会发现，Channel#register(Selector selector, int ops, Object attachment) 方法的第 3 个参数，我们注册了 SelectionKey 的 attachment 属性为 new ArrayList\u0026lt;String\u0026gt;() ，这又是为什么呢？结合下面的 #handleReadableKey(Selection key) 方法，我们一起解析。\n2.2.3 handleReadableKey 对应【第 71 至 93 行】的代码。\n第 73 行：调用 SelectionKey#channel() 方法，获得该 SelectionKey 对应的 SocketChannel ，即客户端的 SocketChannel 。\n第 75 行：调用 CodecUtil#read(SocketChannel channel) 方法，读取数据。具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // CodecUtil.java public static ByteBuffer read(SocketChannel channel) { // 注意，不考虑拆包的处理 ByteBuffer buffer = ByteBuffer.allocate(1024); try { int count = channel.read(buffer); if (count == -1) { return null; } } catch (IOException e) { throw new RuntimeException(e); } return buffer; } 考虑到示例的简单性，数据的读取，就不考虑拆包的处理。不理解的胖友，可以自己 Google 下。\n调用 SocketChannel#read(ByteBuffer) 方法，读取 Channel 的缓冲区的数据到 ByteBuffer 中。若返回的结果( count ) 为 -1 ，意味着客户端连接已经断开，我们直接返回 null 。为什么是返回 null 呢？下面继续见分晓。\n第 76 至 81 行：若读取数据返回的结果为 null 时，意味着客户端的连接已经断开，因此取消注册 selector 对该客户端的 SocketChannel 的感兴趣的 IO 事件。通过调用注册方法，并且第 2 个参数 ops 为 0 ，可以达到取消注册的效果。😈 感兴趣的胖友，可以将这行代码进行注释，测试下效果就很容易明白了。\n第 83 行：通过调用 ByteBuffer#position() 大于 0 ，来判断实际读取到数据。\n所以，此处笔者在示例中，处理的方式为添加响应数据到 responseQueue 中，并在【第 91 行】的代码中，注册客户端的 SocketChannel 到 selector 中，并对 SelectionKey.OP_WRITE 事件感兴趣。这样子，在 SocketChannel 写就绪时，在 #handleWritableKey(SelectionKey key) 方法中，统一处理写数据给客户端。\n当然，还是因为是示例，所以这样的实现方式不是最优。在 Netty 中，具体的实现方式是，先尝试调用 SocketChannel#write(ByteBuf) 方法，写数据给客户端。若写入失败( 方法返回结果为 0 )时，再进行类似笔者的上述实现方式。牛逼！Netty ！\n如果不太理解分享的原因，可以再阅读如下两篇文章：\n《深夜对话：NIO 中 SelectionKey.OP_WRITE 你了解多少》\n《Java.nio 中 socketChannle.write() 返回 0 的简易解决方案》\n😈 如果不理解，木有关系，在 《精尽 Dubbo 源码分析 —— NIO 服务器（二）之 Transport 层》「8. Dispacher」 中，有详细解析。\n🙂 考虑到示例的简洁性，所以在【第 88 至 89 行】的代码中，我们直接返回（\u0026quot;响应：\u0026quot; + 请求内容）给客户端。\n注意，需要调用 ByteBuffer#flip() 方法，将 ByteBuffer 从写模式切换到读模式。\n第 84 至 85 行：调用 CodecUtil#newString(ByteBuffer) 方法，格式化为字符串，并进行打印。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // CodecUtil.java public static String newString(ByteBuffer buffer) { buffer.flip(); byte\\[\\] bytes = new byte\\[buffer.remaining()\\]; System.arraycopy(buffer.array(), buffer.position(), bytes, 0, buffer.remaining()); try { return new String(bytes, \u0026#34;UTF-8\u0026#34;); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } } 第 86 行：一般在此处，我们可以进行一些业务逻辑的处理，并返回处理的相应结果。例如，我们熟悉的 Request / Response 的处理。当然，考虑到性能，我们甚至可以将逻辑的处理，丢到逻辑线程池。\n第 88 行：通过调用 SelectionKey#attachment() 方法，获得我们附加在 SelectionKey 的响应队列( responseQueue )。可能有胖友会问啦，为什么不调用 SocketChannel#write(ByteBuf) 方法，直接写数据给客户端呢？虽然大多数情况下，SocketChannel 都是可写的，但是如果写入比较频繁，超过 SocketChannel 的缓存区大小，就会导致数据“丢失”，并未写给客户端。\n第 91 行：有一点需要注意，Channel#register(Selector selector, int ops, Object attachment) 方法的第 3 个参数，需要继续传入响应队列( responseQueue )，因为每次注册生成新的 SelectionKey 。若不传入，下面的 #handleWritableKey(SelectionKey key) 方法，会获得不到响应队列( responseQueue )。\n2.2.4 handleWritableKey 对应【第 96 至 112 行】的代码。\n第 98 行：调用 SelectionKey#channel() 方法，获得该 SelectionKey 对应的 SocketChannel ，即客户端的 SocketChannel 。\n第 101 行：通过调用 SelectionKey#attachment() 方法，获得我们附加在 SelectionKey 的响应队列( responseQueue )。\n代码比较简单，还是要注意，需要调用 ByteBuffer#flip() 方法，将 ByteBuffer 从写模式切换到读模式。\n第 102 行：遍历响应队列。\n第 106 行：调用 CodeUtil#write(SocketChannel, content) 方法，写入响应数据给客户端。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // CodecUtil.java public static void write(SocketChannel channel, String content) { // 写入 Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); try { buffer.put(content.getBytes(\u0026#34;UTF-8\u0026#34;)); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } // 写入 Channel buffer.flip(); try { // 注意，不考虑写入超过 Channel 缓存区上限。 channel.write(buffer); } catch (IOException e) { throw new RuntimeException(e); } } 第 111 行：注意，再结束写入后，需要重新注册客户端的 SocketChannel 到 selector 中，并对 SelectionKey.OP_READ 事件感兴趣。为什么呢？其实还是我们在上文中提到的，大多数情况下，SocketChannel 都是写就绪的，如果不取消掉注册掉对 SelectionKey.OP_READ 事件感兴趣，就会导致反复触发无用的写事件处理。😈 感兴趣的胖友，可以将这行代码进行注释，测试下效果就很容易明白了。\n2.3 main 对应【第 114 至 116 行】\n比较简单，就是创建一个 NioServer 对象。 撸到此处，我们可以直接通过 telnet 127.0.0.1 8080 的方式，连接服务端，进行读写数据的测试。\n3. 客户端 客户端的实现代码，绝大数和服务端相同，所以我们分析的相对会简略一些。不然，自己都嫌弃自己太啰嗦了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 1: public class NioClient { 2: 3: private SocketChannel clientSocketChannel; 4: private Selector selector; 5: private final List\u0026lt;String\u0026gt; responseQueue = new ArrayList\u0026lt;String\u0026gt;(); 6: 7: private CountDownLatch connected = new CountDownLatch(1); 8: 9: public NioClient() throws IOException, InterruptedException { 10: // 打开 Client Socket Channel 11: clientSocketChannel = SocketChannel.open(); 12: // 配置为非阻塞 13: clientSocketChannel.configureBlocking(false); 14: // 创建 Selector 15: selector = Selector.open(); 16: // 注册 Server Socket Channel 到 Selector 17: clientSocketChannel.register(selector, SelectionKey.OP_CONNECT); 18: // 连接服务器 19: clientSocketChannel.connect(new InetSocketAddress(8080)); 20: 21: new Thread(new Runnable() { 22: @Override 23: public void run() { 24: try { 25: handleKeys(); 26: } catch (IOException e) { 27: e.printStackTrace(); 28: } 29: } 30: }).start(); 31: 32: if (connected.getCount() != 0) { 33: connected.await(); 34: } 35: System.out.println(\u0026#34;Client 启动完成\u0026#34;); 36: } 37: 38: @SuppressWarnings(\u0026#34;Duplicates\u0026#34;) 39: private void handleKeys() throws IOException { 40: while (true) { 41: // 通过 Selector 选择 Channel 42: int selectNums = selector.select(30 \\* 1000L); 43: if (selectNums == 0) { 44: continue; 45: } 46: 47: // 遍历可选择的 Channel 的 SelectionKey 集合 48: Iterator\u0026lt;SelectionKey\u0026gt; iterator = selector.selectedKeys().iterator(); 49: while (iterator.hasNext()) { 50: SelectionKey key = iterator.next(); 51: iterator.remove(); // 移除下面要处理的 SelectionKey 52: if (!key.isValid()) { // 忽略无效的 SelectionKey 53: continue; 54: } 55: 56: handleKey(key); 57: } 58: } 59: } 60: 61: private synchronized void handleKey(SelectionKey key) throws IOException { 62: // 接受连接就绪 63: if (key.isConnectable()) { 64: handleConnectableKey(key); 65: } 66: // 读就绪 67: if (key.isReadable()) { 68: handleReadableKey(key); 69: } 70: // 写就绪 71: if (key.isWritable()) { 72: handleWritableKey(key); 73: } 74: } 75: 76: private void handleConnectableKey(SelectionKey key) throws IOException { 77: // 完成连接 78: if (!clientSocketChannel.isConnectionPending()) { 79: return; 80: } 81: clientSocketChannel.finishConnect(); 82: // log 83: System.out.println(\u0026#34;接受新的 Channel\u0026#34;); 84: // 注册 Client Socket Channel 到 Selector 85: clientSocketChannel.register(selector, SelectionKey.OP_READ, responseQueue); 86: // 标记为已连接 87: connected.countDown(); 88: } 89: 90: @SuppressWarnings(\u0026#34;Duplicates\u0026#34;) 91: private void handleReadableKey(SelectionKey key) throws ClosedChannelException { 92: // Client Socket Channel 93: SocketChannel clientSocketChannel = (SocketChannel) key.channel(); 94: // 读取数据 95: ByteBuffer readBuffer = CodecUtil.read(clientSocketChannel); 96: // 打印数据 97: if (readBuffer.position() \u0026gt; 0) { // 写入模式下， 98: String content = CodecUtil.newString(readBuffer); 99: System.out.println(\u0026#34;读取数据：\u0026#34; \\+ content); 100: } 101: } 102: 103: @SuppressWarnings(\u0026#34;Duplicates\u0026#34;) 104: private void handleWritableKey(SelectionKey key) throws ClosedChannelException { 105: // Client Socket Channel 106: SocketChannel clientSocketChannel = (SocketChannel) key.channel(); 107: 108: // 遍历响应队列 109: List\u0026lt;String\u0026gt; responseQueue = (ArrayList\u0026lt;String\u0026gt;) key.attachment(); 110: for (String content : responseQueue) { 111: // 打印数据 112: System.out.println(\u0026#34;写入数据：\u0026#34; \\+ content); 113: // 返回 114: CodecUtil.write(clientSocketChannel, content); 115: } 116: responseQueue.clear(); 117: 118: // 注册 Client Socket Channel 到 Selector 119: clientSocketChannel.register(selector, SelectionKey.OP_READ, responseQueue); 120: } 121: 122: public synchronized void send(String content) throws ClosedChannelException { 123: // 添加到响应队列 124: responseQueue.add(content); 125: // 打印数据 126: System.out.println(\u0026#34;写入数据：\u0026#34; \\+ content); 127: // 注册 Client Socket Channel 到 Selector 128: clientSocketChannel.register(selector, SelectionKey.OP_WRITE, responseQueue); 129: selector.wakeup(); 130: } 131: 132: public static void main(String\\[\\] args) throws IOException, InterruptedException { 133: NioClient client = new NioClient(); 134: for (int i = 0; i \u0026lt; 30; i++) { 135: client.send(\u0026#34;nihao: \u0026#34; \\+ i); 136: Thread.sleep(1000L); 137: } 138: } 139: 140: } 整块代码我们可以分成 3 部分：\n构造方法：初始化 NIO 客户端。\n#handleKeys() 方法：基于 Selector 处理 IO 操作。\n#main(String[] args) 方法：创建 NIO 客户端，并向服务器发送请求数据。\n下面，我们逐小节来分享。\n3.1 构造方法 对应【第 3 至 36 行】的代码。\nclientSocketChannel 属性，客户端的 SocketChannel ，在【第 9 至 13 行】和【第 19 行】的代码进行初始化，重点是此处连接了指定服务端。\nselector 属性，选择器，在【第 14 至 17 行】的代码进行初始化，重点是此处将 clientSocketChannel 到 selector 中，并对 SelectionKey.OP_CONNECT 事件感兴趣。这样子，在客户端连接服务端成功时，我们就可以处理该 IO 事件。\nresponseQueue 属性，直接声明为 NioClient 的成员变量，是为了方便 #send(String content) 方法的实现。\n第 21 至 30 行：调用 #handleKeys() 方法，基于 Selector 处理 IO 事件。比较特殊的是，我们是启动了一个线程进行处理。因为在后续的 #main() 方法中，我们需要调用发送请求数据的方法，不能直接在主线程，轮询处理 IO 事件。😈 机智的胖友，可能已经发现，NioServer 严格来说，也是应该这样处理。\n第 32 至 34 行：通过 CountDownLatch 来实现阻塞等待客户端成功连接上服务端。具体的 CountDownLatch#countDown() 方法，在 #handleConnectableKey(SelectionKey key) 方法中调用。当然，除了可以使用 CountDownLatch 来实现阻塞等待，还可以通过如下方式:\nObject 的 wait 和 notify 的方式。\nLock 的 await 和 notify 的方式。\nQueue 的阻塞等待方式。\n😈 开心就好，皮一下很开心。\n3.2 handleKeys 对应【第 38 至 59 行】的代码。\n完全和 NioServer 中的该方法一模一样，省略。\n3.2.1 handleKey 对应【第 61 至 74 行】的代码。\n大体逻辑和 NioServer 中的该方法一模一样，差别将对 SelectionKey.OP_WRITE 事件的处理改成对 SelectionKey.OP_CONNECT 事件的处理。\n3.3.2 handleConnectableKey 对应【第 76 至 88 行】的代码。\n第 77 至 81 行：判断客户端的 SocketChannel 上是否正在进行连接的操作，若是，则完成连接。\n第 83 行：打印日志。\n第 85 行：注册客户端的 SocketChannel 到 selector 中，并对 SelectionKey.OP_READ 事件感兴趣。这样子，在客户端接收到到服务端的消息( 数据 )时，我们就可以处理该 IO 事件。\n第 87 行：调用 CountDownLatch#countDown() 方法，结束 NioClient 构造方法中的【第 32 至 34 行】的阻塞等待连接完成。\n3.3.3 handleReadableKey 对应【第 91 至 101 行】的代码。\n大体逻辑和 NioServer 中的该方法一模一样，去掉响应请求的相关逻辑。😈 如果不去掉，就是客户端和服务端互发消息的“死循环”了。\n3.3.4 handleWritableKey 对应【第 103 至 120 行】的代码。\n完全和 NioServer 中的该方法一模一样。\n3.3 send 对应【第 122 至 130 行】的代码。\n客户端发送请求消息给服务端。\n第 124 行：添加到响应队列( responseQueue ) 中。\n第 126 行：打印日志。\n第 128 行：注册客户端的 SocketChannel 到 selector 中，并对 SelectionKey.OP_WRITE 事件感兴趣。具体的原因，和 NioServer 的 #handleReadableKey(SelectionKey key) 方法的【第 88 行】一样。\n第 129 行：调用 Selector#wakeup() 方法，唤醒 #handleKeys() 方法中，Selector#select(long timeout) 方法的阻塞等待。\n因为，在 Selector#select(long timeout) 方法的实现中，是以调用当时，对 SocketChannel 的感兴趣的事件 。\n所以，在【第 128 行】的代码中，即使修改了对 SocketChannel 的感兴趣的事件，也不会结束 Selector#select(long timeout) 方法的阻塞等待。因此，需要进行唤醒操作。\n😈 感兴趣的胖友，可以将这行代码进行注释，测试下效果就很容易明白了。\n3.4 main 对应【第 132 至 137 行】的代码。\n第 133 行：创建一个 NioClient 对象。\n第 134 至 137 行：每秒发送一次请求。考虑到代码没有处理拆包的逻辑，所以增加了间隔 1 秒的 sleep 。\n","date":"2023-05-04T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94/","title":"netty源码分析五"},{"content":"精尽 Netty 源码分析 —— NIO 基础（一）之简介 1. 概述 Java NIO( New IO 或者 Non Blocking IO ) ，从 Java 1.4 版本开始引入的非阻塞 IO ，用于替换标准( 有些文章也称为传统，或者 Blocking IO 。下文统称为 BIO ) Java IO API 的 IO API 。\n老艿艿：在一些文章中，会将 Java NIO 描述成异步 IO ，实际是不太正确的： Java NIO 是同步 IO ，Java AIO ( 也称为 NIO 2 )是异步 IO。具体原因，推荐阅读文章：\n《异步和非阻塞一样吗? (内容涉及 BIO, NIO, AIO, Netty)》 。\n《BIO与NIO、AIO的区别(这个容易理解)》\n总结来说，在 Unix IO 模型的语境下：\n同步和异步的区别：数据拷贝阶段是否需要完全由操作系统处理。\n阻塞和非阻塞操作：是针对发起 IO 请求操作后，是否有立刻返回一个标志信息而不让请求线程等待。\n因此，Java NIO 是同步且非阻塞的 IO 。\n2. 核心组件 Java NIO 由如下三个核心组件组成：\nChannel\nBuffer\nSelector\n后续的每篇文章，我们会分享对应的一个组件。\n3. NIO 和 BIO 的对比 NIO 和 BIO 的区别主要体现在三个方面：\nNIO\nBIO\n基于缓冲区( Buffer )\n基于流( Stream )\n非阻塞 IO\n阻塞 IO\n选择器( Selector )\n无\n其中，选择器( Selector )是 NIO 能实现非阻塞的基础。 3.1 基于 Buffer 与基于 Stream BIO 是面向字节流或者字符流的，而在 NIO 中，它摒弃了传统的 IO 流，而是引入 Channel 和 Buffer 的概念：从 Channel 中读取数据到 Buffer 中，或者将数据从 Buffer 中写到 Channel 中。\n① 那么什么是基于 Stream呢？\n在一般的 Java IO 操作中，我们以流式的方式，顺序的从一个 Stream 中读取一个或者多个字节，直至读取所有字节。因为它没有缓存区，所以我们就不能随意改变读取指针的位置。\n② 那么什么是基于 Buffer 呢？\n基于 Buffer 就显得有点不同了。我们在从 Channel 中读取数据到 Buffer 中，这样 Buffer 中就有了数据后，我们就可以对这些数据进行操作了。并且不同于一般的 Java IO 操作那样是顺序操作，NIO 中我们可以随意的读取任意位置的数据，这样大大增加了处理过程中的灵活性。\n老艿艿：写入操作，也符合上述读取操作的情况。\n3.2 阻塞与非阻塞 IO Java IO 的各种流是阻塞的 IO 操作。这就意味着，当一个线程执行读或写 IO 操作时，该线程会被阻塞，直到有一些数据被读取，或者数据完全写入。\nJava NIO 可以让我们非阻塞的使用 IO 操作。例如：\n当一个线程执行从 Channel 执行读取 IO 操作时，当此时有数据，则读取数据并返回；当此时无数据，则直接返回而不会阻塞当前线程。\n当一个线程执行向 Channel 执行写入 IO 操作时，不需要阻塞等待它完全写入，这个线程同时可以做别的事情。\n也就是说，线程可以将非阻塞 IO 的空闲时间用于在其他 Channel 上执行 IO 操作。所以，一个单独的线程，可以管理多个 Channel 的读取和写入 IO 操作。\n3.3 Selector Java NIO 引入 Selector ( 选择器 )的概念，它是 Java NIO 得以实现非阻塞 IO 操作的最最最关键。\n我们可以注册多个 Channel 到一个 Selector 中。而 Selector 内部的机制，就可以自动的为我们不断的执行查询( select )操作，判断这些注册的 Channel 是否有已就绪的 IO 事件( 例如可读，可写，网络连接已完成 )。\n通过这样的机制，一个线程通过使用一个 Selector ，就可以非常简单且高效的来管理多个 Channel 了。\n4. NIO 和 AIO 的对比 考虑到 Netty 4.1.X 版本实际并未基于 Java AIO 实现，所以我们就省略掉这块内容。那么，感兴趣的同学，可以自己 Google 下 Java NIO 和 Java AIO 的对比。\n具体为什么 Netty 4.1.X 版本不支持 Java AIO 的原因，可参见 《Netty（二）：Netty 为啥去掉支持 AIO ?》 文章。\n也因此，Netty 4.1.X 一般情况下，使用的是同步非阻塞的 NIO 模型。当然，如果真的有必要，也可以使用同步阻塞的 BIO 模型。\n","date":"2023-05-04T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/","title":"netty源码分析一"},{"content":"数据库基础 数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。\n什么是数据库 数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。\n在JavaSE学习阶段中，我们学习了如何使用文件I/O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！\n而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！\n常见的数据库 常见的数据库有很多种，包括但不限于：\nMySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统 而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。\n数据模型 数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：\n属性不可再分 一个实体的属性可以有很多个 用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的 属性取值可以有一定的约束，比如性别只能是男或是女 实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m）\nMySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。\n通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。\n数据库的创建 既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：\n学生表：用于存放所有学生的数据，学生（学号，姓名，性别） 教师表：用于存放所有教师的数据，教师（教师号，姓名） 授课表：用于存放教师与学生的授课信息，授课（学号，教师号） 其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。\n为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。\n数据库的规范化 要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。\n第一范式（1NF） 第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：\n学生（姓名，电话号码） 电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为：\n学生（姓名，座机号码，手机号码） 满足第一范式是关系型数据库最基本的要求！\n第二范式（2NF） 第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：\n学生（学号，姓名，性别） 学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。\n第三范式（3NF） 在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。\n学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者） 实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：\n学生借书情况（借阅编号，学生学号，书籍编号） 书籍（书籍编号，书籍名称，书籍作者） 这样就消除了传递依赖，从而满足第三范式。\nBCNF BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：\n(仓库ID, 存储物品ID) →(管理员ID, 数量)\n(管理员ID, 存储物品ID) → (仓库ID, 数量)\n所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：\n(仓库ID) → (管理员ID)\n(管理员ID) → (仓库ID)\n即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。\n认识SQL语句 结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。\nSQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！\nSQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。\n我们要学习的就是以下四种类型的SQL语言：\n数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。 数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。 我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）\n数据库定义语言（DDL） 数据库操作 我们可以通过create database来创建一个数据库：\n1 create database 数据库名 为了能够支持中文，我们在创建时可以设定编码格式：\n1 CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库：\n1 drop database 数据库名 创建表 数据库创建完成后，我们一般通过create table语句来创建一张表：\n1 2 3 4 create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) SQL数据类型 以下的数据类型用于字符串存储：\nchar(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。 varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。 以下数据类型用于存储数字：\nsmallint用于存储小的整数，范围在 (-32768，32767) int用于存储一般的整数，范围在 (-2147483648，2147483647) bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807) float用于存储单精度小数 double用于存储双精度的小数 以下数据类型用于存储时间：\ndate存储日期 time存储时间 year存储年份 datetime用于混合存储日期+时间 列级约束条件 列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null\n表级约束条件 表级约束有四种：主键、外键、唯一、检查\n现在我们通过SQL语句来创建我们之前提到的三张表。\n1 [CONSTRAINT \u0026lt;外键名\u0026gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES \u0026lt;主表名\u0026gt; 主键列1 [，主键列2，…] 修改表 如果我们想修改表结构，我们可以通过alter table来进行修改：\n1 2 3 ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] 我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。\n删除表 我们可以通过drop table来删除一个表：\n1 DROP TABLE 表名[restrict|cascade] 其中restrict和cascade上面的效果一致。\n数据库操纵语言（DML） 前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。\n插入数据 通过使用insert into语句来向数据库中插入一条数据（一条记录）：\n1 INSERT INTO 表名 VALUES(值1, 值2, 值3) 如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：\n1 INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2) 我们也可以一次性向数据库中插入多条数据：\n1 INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2) 我们来试试看向我们刚刚创建的表中添加三条数据。\n修改数据 我们可以通过update语句来更新表中的数据：\n1 UPDATE 表名 SET 列名=值,... WHERE 条件 注意，SQL语句中的等于判断是=\n**警告：**如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！\n删除数据 我们可以通过使用delete来删除表中的数据：\n1 DELETE FROM 表名 通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据：\n1 DELETE FROM 表名 WHERE 条件 数据库查询语言（DQL） 数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。\n单表查询 单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询：\n1 2 3 4 5 6 7 8 -- 指定查询某一列数据 SELECT 列名[,列名] FROM 表名 -- 会以别名显示此列 SELECT 列名 别名 FROM 表名 -- 查询所有的列数据 SELECT * FROM 表名 -- 只查询不重复的值 SELECT DISTINCT 列名 FROM 表名 我们也可以添加where字句来限定查询目标：\n1 SELECT * FROM 表名 WHERE 条件 常用查询条件 一般的比较运算符，包括=、\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、!=等。 是否在集合中：in、not in 字符模糊匹配：like，not like 多重条件连接查询：and、or、not 我们来尝试使用一下上面这几种条件。\n排序查询 我们可以通过order by来将查询结果进行排序：\n1 SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC 使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。\n我们也可以可以同时添加多个排序：\n1 SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC 这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。\n聚集函数 聚集函数一般用作统计，包括：\ncount([distinct]*)统计所有的行数（distinct表示去重再统计，下同） count([distinct]列名)统计某列的值总和 sum([distinct]列名)求一列的和（注意必须是数字类型的） avg([distinct]列名)求一列的平均值（注意必须是数字类型） max([distinct]列名)求一列的最大值 min([distinct]列名)求一列的最小值 一般聚集函数是这样使用的：\n1 SELECT count(distinct 列名) FROM 表名 WHERE 条件 分组和分页查询 通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用：\n1 SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 我们还可以添加having来限制分组条件：\n1 SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 我们可以通过limit来限制查询的数量，只取前n个结果：\n1 SELECT * FROM 表名 LIMIT 数量 我们也可以进行分页：\n1 SELECT * FROM 表名 LIMIT 起始位置,数量 多表查询 多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。\n1 SELECT * FROM 表1, 表2 直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。\n1 SELECT * FROM 表1, 表2 WHERE 条件 这样，只会从笛卡尔积的结果中得到满足条件的数据。\n**注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。\n自身连接查询 自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：\n1 SELECT * FROM 表名 别名1, 表名 别名2 其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。\n外连接查询 外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：\n通过使用inner join进行内连接，只会返回两个表满足条件的交集部分： 通过使用left join进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： 嵌套查询 我们可以将查询的结果作为另一个查询的条件，比如：\n1 SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) 我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。\n数据库控制语言（DCL） 庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。\n创建用户 我们可以通过create user来创建用户：\n1 CREATE USER 用户名 identified by 密码; 也可以不带密码：\n1 CREATE USER 用户名; 我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。\n登陆用户 首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：\n1 login -u 用户名 -p 输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：\n1 show databases; 我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！\n用户授权 我们可以通过使用grant来为一个数据库用户进行授权：\n1 grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] 其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。\n我们可以使用revoke来收回一个权限：\n1 revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 视图 视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。\n我们可以通过create view来创建视图;\n1 CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。\n若视图是由两个以上基本表导出的，则此视图不允许更新。 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新。 若视图定义中含有DISTINCT短语，则此视图不允许更新。 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade \u0026gt; (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。 一个不允许更新的视图上定义的视图也不允许更新 通过drop来删除一个视图：\n1 drop view apptest 索引 在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：\n1 2 3 4 -- 创建索引 CREATE INDEX 索引名称 ON 表名 (列名) -- 查看表中的索引 show INDEX FROM student 我们也可以通过下面的命令删除一个索引：\n1 drop index 索引名称 on 表名 虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。\n触发器 触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。\n触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）\n比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。\n1 CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！\n通过下面的命令来查看触发器：\n1 SHOW TRIGGERS 如果不需要，我们就可以删除此触发器：\n1 DROP TRIGGER 触发器名称 事务 当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：\n1 SHOW ENGINES; MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。\n事务具有以下特性：\n**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 我们通过以下例子来探究以下事务：\n1 2 3 4 5 6 7 8 begin; #开始事务 ... rollback; #回滚事务 savepoint 回滚点; #添加回滚点 rollback to 回滚点; #回滚到指定回滚点 ... commit; #提交事务 -- 一旦提交，就无法再进行回滚了！ 选学内容 函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。\n","date":"2023-05-03T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/javaweb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","title":"JavaWeb数据库基础"},{"content":"Java网络编程 在JavaSE阶段，我们学习了I/O流，既然I/O流如此强大，那么能否跨越不同的主机进行I/O操作呢？这就要提到Java的网络编程了。\n**注意：**本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识）\n计算机网络基础 利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。\n比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。\n既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了：\n每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络）\n而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分：\n因此，我们一般看到的是这样的：192.168.0.11:8080，通过IP:端口的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！\nIP地址分为IPv4和IPv6，IPv4类似于192.168.0.11，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址0.0.0.0表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为255.255.255.255，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：1030::C9B4:FF12:48AA:1A2B，目前也正在向IPv6的阶段过度。\nTCP和UDP是两种不同的传输层协议：\nTCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。 UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。 了解Socket技术 通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。\n要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！\n1 2 3 4 5 6 7 8 9 10 //服务端 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\u0026#34;正在等待客户端连接...\u0026#34;); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(\u0026#34;客户端已连接，IP地址为：\u0026#34;+socket.getInetAddress().getHostAddress()); }catch (IOException e){ e.printStackTrace(); } } 1 2 3 4 5 6 7 8 9 //客户端 public static void main(String[] args) { try (Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080)){ System.out.println(\u0026#34;已连接到服务端！\u0026#34;); }catch (IOException e){ System.out.println(\u0026#34;服务端连接失败！\u0026#34;); e.printStackTrace(); } } 实际上它就是一个TCP连接的建立过程：\n一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\u0026#34;正在等待客户端连接...\u0026#34;); while (true){ //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(\u0026#34;客户端已连接，IP地址为：\u0026#34;+socket.getInetAddress().getHostAddress()); } }catch (IOException e){ e.printStackTrace(); } } 现在我们就可以多次去连接此服务端了。\n使用Socket进行数据传输 通过Socket对象，我们就可以获取到对应的I/O流进行网络数据传输：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void main(String[] args) { try (Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\u0026#34;已连接到服务端！\u0026#34;); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\u0026#34;请输入要发送给服务端的内容：\u0026#34;); String text = scanner.nextLine(); writer.write(text+\u0026#39;\\n\u0026#39;); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\u0026#34;数据已发送：\u0026#34;+text); }catch (IOException e){ System.out.println(\u0026#34;服务端连接失败！\u0026#34;); e.printStackTrace(); }finally { System.out.println(\u0026#34;客户端断开连接！\u0026#34;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\u0026#34;正在等待客户端连接...\u0026#34;); Socket socket = server.accept(); System.out.println(\u0026#34;客户端已连接，IP地址为：\u0026#34;+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\u0026#34;接收到客户端数据：\u0026#34;); System.out.println(reader.readLine()); socket.close(); //和服务端TCP连接完成之后，记得关闭socket }catch (IOException e){ e.printStackTrace(); } } 同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { try (Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); Scanner scanner = new Scanner(System.in)){ System.out.println(\u0026#34;已连接到服务端！\u0026#34;); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(\u0026#34;请输入要发送给服务端的内容：\u0026#34;); String text = scanner.nextLine(); writer.write(text+\u0026#39;\\n\u0026#39;); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(\u0026#34;数据已发送：\u0026#34;+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\u0026#34;收到服务器返回：\u0026#34;+reader.readLine()); }catch (IOException e){ System.out.println(\u0026#34;服务端连接失败！\u0026#34;); e.printStackTrace(); }finally { System.out.println(\u0026#34;客户端断开连接！\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\u0026#34;正在等待客户端连接...\u0026#34;); Socket socket = server.accept(); System.out.println(\u0026#34;客户端已连接，IP地址为：\u0026#34;+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(\u0026#34;接收到客户端数据：\u0026#34;); System.out.println(reader.readLine()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\u0026#34;已收到！\u0026#34;); writer.flush(); }catch (IOException e){ e.printStackTrace(); } } 我们可以手动关闭单向的流：\n1 2 socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间：\n1 socket.setSoTimeout(3000); 当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.test.Main.main(Main.java:41) 我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？\n1 2 3 try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in)){ socket.connect(new InetSocketAddress(\u0026#34;localhost\u0026#34;, 8080), 1000); //手动调用connect方法进行连接 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生：\n1 socket.setKeepAlive(true); 当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP/IP连接是否有效。\nTCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收：\n此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：\n1 2 socket.setReceiveBufferSize(25565); //TCP接收缓冲区 socket.setSendBufferSize(25565); //TCP发送缓冲区 使用Socket传输文件 既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。\n使用浏览器访问Socket服务器 在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\u0026#34;正在等待客户端连接...\u0026#34;); Socket socket = server.accept(); System.out.println(\u0026#34;客户端已连接，IP地址为：\u0026#34;+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(\u0026#34;接收到客户端数据：\u0026#34;); while (true){ int i = in.read(); if(i == -1) break; System.out.print((char) i); } }catch (Exception e){ e.printStackTrace(); } } 我们现在打开浏览器，输入http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。\n我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET / HTTP/1.1 Host: 127.0.0.1:8080 Connection: keep-alive Cache-Control: max-age=0 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;94\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;94\u0026#34;, \u0026#34;;Not A Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;macOS\u0026#34; Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7 实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。\n既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码：\n1 HTTP/1.1 200 Accpeted 然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)){ //将服务端创建在端口8080上 System.out.println(\u0026#34;正在等待客户端连接...\u0026#34;); Socket socket = server.accept(); System.out.println(\u0026#34;客户端已连接，IP地址为：\u0026#34;+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.println(\u0026#34;接收到客户端数据：\u0026#34;); while (reader.ready()) System.out.println(reader.readLine()); //ready是判断当前流中是否还有可读内容 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\u0026#34;HTTP/1.1 200 Accepted\\r\\n\u0026#34;); //200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多） writer.write(\u0026#34;\\r\\n\u0026#34;); //在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容） writer.write(\u0026#34;lbwnb!\u0026#34;); writer.flush(); }catch (Exception e){ e.printStackTrace(); } } 我们可以打开浏览器的开发者模式（这里推荐使用Chrome/Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。\n","date":"2023-05-03T00:00:00Z","permalink":"https://tauzi.github.io/myblog/p/javaweb%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"JavaWeb网络编程"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) [Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://tauzi.github.io/myblog/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://tauzi.github.io/myblog/p/test-chinese/","title":"Chinese Test"}]