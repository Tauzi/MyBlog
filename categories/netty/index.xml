<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Netty on TauZZ&#39;s Blog</title>
        <link>https://tauzi.github.io/myblog/categories/netty/</link>
        <description>Recent content in Netty on TauZZ&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 04 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://tauzi.github.io/myblog/categories/netty/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>netty面试题</title>
        <link>https://tauzi.github.io/myblog/p/netty%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
        <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://tauzi.github.io/myblog/p/netty%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
        <description>&lt;h1 id=&#34;精尽-netty-面试题&#34;&gt;精尽 Netty 面试题&lt;/h1&gt;
&lt;p&gt;以下面试题，转载芋道源码&lt;/p&gt;
&lt;h2 id=&#34;bio-是什么&#34;&gt;BIO 是什么？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BIO ，全称 Block-IO ，是一种&lt;strong&gt;阻塞&lt;/strong&gt; + &lt;strong&gt;同步&lt;/strong&gt;的通信模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务器通过一个 Acceptor 线程，负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的&lt;strong&gt;一请求一应答模式&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若客户端数量增多，频繁地创建和销毁线程会给服务器打开很大的压力。后改良为用线程池的方式代替新增线程，被称为伪异步 IO 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码参见 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io/src/com/itdragon/bio&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;bio&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BIO 模型中，通过 Socket 和 ServerSocket 实现套接字通道的通信。阻塞，同步，建立连接耗时。&lt;/p&gt;
&lt;h2 id=&#34;nio-是什么&#34;&gt;NIO 是什么？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NIO ，全称 New IO ，也叫 Non-Block IO ，是一种&lt;strong&gt;非阻塞&lt;/strong&gt; + 同步的通信模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（一）之简介》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NIO 相对于 BIO 来说一大进步。客户端和服务器之间通过 Channel 通信。NIO 可以在 Channel 进行读写操作。这些 Channel 都会被注册在 Selector 多路复用器上。Selector 通过一个线程不停的轮询这些 Channel 。找出已经准备就绪的 Channel 执行 IO 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NIO 通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞 NIO 的特点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器端只要提供一个线程负责 Selector 的轮询，就可以接入成千上万个客户端，这就是 JDK NIO 库的巨大进步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（四）之 Selector》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通道分为两大类：一类是网络读写（SelectableChannel），一类是用于文件操作（FileChannel）。我们使用的是前者 SocketChannel 和 ServerSocketChannel ，都是SelectableChannel 的子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（二）之 Channel》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BIO 是将数据直接写入或读取到流 Stream 对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NIO 的数据操作都是在 Buffer 中进行的。Buffer 实际上是一个数组。Buffer 最常见的类型是ByteBuffer，另外还有 CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（三）之 Buffer》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区 Buffer ：它是 NIO 与 BIO 的一个重要区别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通道 Channel ：和流 Stream 不同，通道是双向的。NIO可以通过 Channel 进行数据的读、写和同时读写操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多路复用器 Selector ：NIO 编程的基础。多路复用器提供选择已经就绪的任务的能力：就是 Selector 会不断地轮询注册在其上的通道（Channel），如果某个通道处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以取得就绪的Channel集合，从而进行后续的 IO 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码参见 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io/src/com/itdragon/nio&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;nio&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（五）之示例》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NIO 模型中通过 SocketChannel 和 ServerSocketChannel 实现套接字通道的通信。非阻塞，同步，避免为每个 TCP 连接创建一个线程。&lt;/p&gt;
&lt;p&gt;🦅 &lt;strong&gt;继续挖掘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能有胖友对非阻塞和阻塞，同步和异步的定义有点懵逼，我们再来看下 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（一）之简介》&lt;/a&gt; 提到的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;老艿艿：在一些文章中，会将 Java NIO 描述成&lt;strong&gt;异步&lt;/strong&gt; IO ，实际是不太正确的： Java NIO 是&lt;strong&gt;同步&lt;/strong&gt; IO ，Java AIO ( 也称为 NIO 2 )是&lt;strong&gt;异步&lt;/strong&gt; IO。具体原因，推荐阅读文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/matthew_zhang/article/details/71328697&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《异步和非阻塞一样吗? (内容涉及 BIO, NIO, AIO, Netty)》&lt;/a&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/skiof007/article/details/52873421&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《BIO与NIO、AIO的区别(这个容易理解)》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来说，在 &lt;strong&gt;Unix IO 模型&lt;/strong&gt;的语境下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步和异步的区别：数据拷贝阶段是否需要完全由操作系统处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞和非阻塞操作：是针对发起 IO 请求操作后，是否有立刻返回一个标志信息而不让请求线程等待。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Java NIO 是&lt;strong&gt;同步&lt;/strong&gt;且非阻塞的 IO 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;另外，胖友在瞅瞅下面这个图来理解下：&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/images/Netty/2017_10_24/01.png&#34;  title=&#34;Unix 的 5 种 IO 模型&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2017_10_24/01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Unix 的 5 种 IO 模型&#34;
	
	
&gt;&lt;/a&gt;Unix 的 5 种 IO 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aio-是什么&#34;&gt;AIO 是什么？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;艿艿：这个面试题，重点在于陈述我们对 BIO、NIO 的理解，对于 AIO 来说，基本理解即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;🦅 &lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AIO ，全称 Asynchronous IO ，也叫 NIO&lt;strong&gt;2&lt;/strong&gt; ，是一种&lt;strong&gt;非阻塞&lt;/strong&gt; + &lt;strong&gt;异步&lt;/strong&gt;的通信模式。在 NIO 的基础上，引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AIO 并没有采用 NIO 的多路复用器，而是使用异步通道的概念。其 read，write 方法的返回类型，都是 Future 对象。而 Future 模型是异步的，其核心思想是：&lt;strong&gt;去主函数等待时间&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码参见 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io/src/com/itdragon/aio&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;aio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AIO 模型中通过 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel 实现套接字通道的通信。非阻塞，异步。&lt;/p&gt;
&lt;h2 id=&#34;bionio-有什么区别&#34;&gt;BIO、NIO 有什么区别？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程模型不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。所以，线程开销大。可改良为用线程池的方式代替新创建线程，被称为伪异步 IO 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有新的 I/O 请求时，才启动一个线程进行处理。可改良为一个线程处理多个请求，基于 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/EventLoop-1-Reactor-Model/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;多 Reactor 模型&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BIO 是面向流( Stream )的，而 NIO 是面向缓冲区( Buffer )的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BIO 的各种操作是阻塞的，而 NIO 的各种操作是非阻塞的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BIO 的 Socket 是单向的，而 NIO 的 Channel 是双向的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能文字比较难记，整理出来就是下图：&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/images/Netty/2017_10_24/02.png&#34;  title=&#34;BIO 对比 NIO 对比 AIO&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2017_10_24/02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;BIO 对比 NIO 对比 AIO&#34;
	
	
&gt;&lt;/a&gt;BIO 对比 NIO 对比 AIO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一点要注意，虽然图中说 NIO 的性能一般，但是在绝大多数我们日常业务场景，NIO 和 AIO 的性能差距实际没这么大。在 Netty5 中，基于 AIO 改造和支持，最后发现，性能并没有想象中这么强悍，所以 Netty5 被废弃，而是继续保持 Netty4 为主版本，使用 NIO 为主。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了胖友能更好的记住和理解 BIO、NIO、AIO 的流程，胖友可以在理解下图：&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/images/Netty/2017_10_24/03.png&#34;  title=&#34;BIO、NIO、AIO 的流程图&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2017_10_24/03.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;BIO、NIO、AIO 的流程图&#34;
	
	
&gt;&lt;/a&gt;BIO、NIO、AIO 的流程图&lt;/p&gt;
&lt;h2 id=&#34;什么是-netty-&#34;&gt;什么是 Netty ？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty 是一款提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。&lt;/p&gt;
&lt;p&gt;也就是说，Netty 是一个基于 NIO 的客户、服务器端编程框架。使用 Netty 可以确保你快速和简单地开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty 相当简化和流线化了网络应用的编程开发过程，例如，TCP 和 UDP 的 socket 服务开发。&lt;/p&gt;
&lt;p&gt;（以上摘自百度百科）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Netty 具有如下特性( 摘自《Netty in Action》 )&lt;/p&gt;
&lt;p&gt;分类&lt;/p&gt;
&lt;p&gt;Netty的特性&lt;/p&gt;
&lt;p&gt;设计&lt;/p&gt;
&lt;p&gt;1. 统一的 API ，支持多种传输类型( 阻塞和非阻塞的 ) &lt;!-- raw HTML omitted --&gt; 2. 简单而强大的线程模型 &lt;!-- raw HTML omitted --&gt; 3. 真正的无连接数据报套接字( UDP )支持 &lt;!-- raw HTML omitted --&gt; 4. 连接逻辑组件( ChannelHander 中顺序处理消息 )以及组件复用( 一个 ChannelHandel 可以被多个ChannelPipeLine 复用 )&lt;/p&gt;
&lt;p&gt;易于使用&lt;/p&gt;
&lt;p&gt;1. 详实的 Javadoc 和大量的示例集 &lt;!-- raw HTML omitted --&gt; 2. 不需要超过 JDK 1.6+ 的依赖&lt;/p&gt;
&lt;p&gt;性能&lt;/p&gt;
&lt;p&gt;拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟( 得益于池化和复用 )，更低的资源消耗以及最少的内存复制&lt;/p&gt;
&lt;p&gt;健壮性&lt;/p&gt;
&lt;p&gt;1. 不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError &lt;!-- raw HTML omitted --&gt; 2. 消除在高速网络中 NIO 应用程序常见的不公平读 / 写比率&lt;/p&gt;
&lt;p&gt;安全性&lt;/p&gt;
&lt;p&gt;完整的 SSL/TLS 以及 StartTLs 支持，可用于受限环境下，如 Applet 和 OSGI&lt;/p&gt;
&lt;p&gt;社区驱动&lt;/p&gt;
&lt;p&gt;发布快速而且频繁&lt;/p&gt;
&lt;h2 id=&#34;为什么选择-netty-&#34;&gt;为什么选择 Netty ？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用简单&lt;/strong&gt;：API 使用简单，开发门槛低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能强大&lt;/strong&gt;：预置了多种编解码功能，支持多种主流协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定制能力强&lt;/strong&gt;：可以通过 ChannelHandler 对通信框架进行灵活的扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能高&lt;/strong&gt;：通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成熟稳定&lt;/strong&gt;：Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;社区活跃&lt;/strong&gt;：版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;案例丰富&lt;/strong&gt;：经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，这个也是我们做技术选型的一些参考点，不仅仅适用于 Netty ，也同样适用于其他技术栈。当然，😈 面试都可以酱紫回答，显得很高端。&lt;/p&gt;
&lt;h2 id=&#34;为什么说-netty-使用简单&#34;&gt;为什么说 Netty 使用简单？&lt;/h2&gt;
&lt;p&gt;🦅 我们假设要搭建一个 Server 服务器，使用 &lt;strong&gt;Java NIO 的步骤&lt;/strong&gt;如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 ServerSocketChannel 。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;绑定监听端口，并配置为非阻塞模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建 Selector，将之前创建的 ServerSocketChannel 注册到 Selector 上，监听 &lt;code&gt;SelectionKey.OP_ACCEPT&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;循环执行 &lt;code&gt;Selector#select()&lt;/code&gt; 方法，轮询就绪的 Channel。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;轮询就绪的 Channel 时，如果是处于 &lt;code&gt;OP_ACCEPT&lt;/code&gt; 状态，说明是新的客户端接入，调用 &lt;code&gt;ServerSocketChannel#accept()&lt;/code&gt; 方法，接收新的客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;设置新接入的 SocketChannel 为非阻塞模式，并注册到 Selector 上，监听 &lt;code&gt;OP_READ&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;如果轮询的 Channel 状态是 &lt;code&gt;OP_READ&lt;/code&gt; ，说明有新的就绪数据包需要读取，则构造 ByteBuffer 对象，读取数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这里，解码数据包的过程，需要我们自己编写。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;艿艿：注意噢，上述步骤还是最简的 Java NIO 启动步骤，不包括&lt;strong&gt;多 Reactor 多线程模型&lt;/strong&gt;噢！可能有胖友不知道什么是 Reactor 模型，在 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/Interview/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;「什么是 Reactor 模型？」&lt;/a&gt; 问题中，我们会详细解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;🦅 使用 &lt;strong&gt;Netty 的步骤&lt;/strong&gt;如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 NIO 线程组 EventLoopGroup 和 ServerBootstrap。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置 ServerBootstrap 的属性：线程组、SO_BACKLOG 选项，设置 NioServerSocketChannel 为 Channel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置业务处理 Handler 和 编解码器 Codec 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定端口，启动服务器程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在业务处理 Handler 中，处理客户端发送的数据，并给出响应。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;🦅 那么相比 Java NIO，使用 Netty 开发程序，都&lt;strong&gt;简化了哪些步骤&lt;/strong&gt;呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无需关心 &lt;code&gt;OP_ACCEPT&lt;/code&gt;、&lt;code&gt;OP_READ&lt;/code&gt;、&lt;code&gt;OP_WRITE&lt;/code&gt; 等等 &lt;strong&gt;IO 操作&lt;/strong&gt;，Netty 已经封装，对我们在使用是透明无感的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 boss 和 worker EventLoopGroup ，Netty 直接提供&lt;strong&gt;多 Reactor 多线程模型&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Netty 中，我们看到有使用一个解码器 FixedLengthFrameDecoder，可以用于处理定长消息的问题，能够解决 &lt;strong&gt;TCP 粘包拆包&lt;/strong&gt;问题，十分方便。如果使用 Java NIO ，需要我们自行实现解码器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;😈 如果胖友不知道如何使用 Java NIO 编写一个 Server ，建议自己去实现以下。 😈 如果胖友没有使用过 Netty 编写一个 Server ，建议去入门下。&lt;/p&gt;
&lt;h2 id=&#34;说说业务中-netty-的使用场景&#34;&gt;说说业务中 Netty 的使用场景？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建高性能、低时延的各种 Java 中间件，Netty 主要作为基础通信框架提供高性能、低时延的通信服务。例如：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RocketMQ ，分布式消息队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dubbo ，服务调用框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring WebFlux ，基于响应式的 Web 框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HDFS ，分布式文件系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket、Protobuf 等协议的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;说说-netty-如何实现高性能&#34;&gt;说说 Netty 如何实现高性能？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程模型&lt;/strong&gt; ：更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存池设计&lt;/strong&gt; ：使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁。并且，内吃吃的内部实现是用一颗二叉查找树，更好的管理内存分配情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存零拷贝&lt;/strong&gt; ：使用 Direct Buffer ，可以使用 Zero-Copy 机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Zero-Copy ，在操作数据时，不需要将数据 Buffer 从一个内存区域拷贝到另一个内存区域。因为少了一次内存的拷贝，因此 CPU 的效率就得到的提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协议支持&lt;/strong&gt; ：提供对 Protobuf 等高性能序列化协议支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用更多本地代码&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用 JNI 提供了 Native Socket Transport ，在使用 Epoll edge-triggered 的情况下，可以有一定的性能提升。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;其它：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用反射等技术直接操纵 SelectionKey ，使用数组而不是 Java 容器等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 &lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000012926809&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FastThreadLocal&lt;/a&gt; 类，当请求频繁时，带来更好的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;hellip;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，推荐阅读白衣大大的两篇文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://calvin1978.blogcn.com/articles/netty-performance.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Netty高性能编程备忘录(上)》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://calvin1978.blogcn.com/articles/netty-performance2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Netty高性能编程备忘录（下）》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;下面三连问！&lt;/p&gt;
&lt;p&gt;Netty 是一个高性能的、高可靠的、可扩展的异步通信框架，那么高性能、高可靠、可扩展设计体现在哪里呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;netty-的高性能如何体现&#34;&gt;Netty 的高性能如何体现？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题，和 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/Interview/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;「说说 Netty 如何实现高性能？」&lt;/a&gt; 问题，会有点重叠。没事，反正理解就好，也背不下来。哈哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;性能是设计出来的，而不是测试出来的。那么，Netty 的架构设计是如何实现高性能的呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程模型&lt;/strong&gt; ：采用异步非阻塞的 I/O 类库，基于 Reactor 模式实现，解决了传统同步阻塞 I/O 模式下服务端无法平滑处理客户端线性增长的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;堆外内存&lt;/strong&gt; ：TCP 接收和发送缓冲区采用直接内存代替堆内存，避免了内存复制，提升了 I/O 读取和写入性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存池设计&lt;/strong&gt; ：支持通过内存池的方式循环利用 ByteBuf，避免了频繁创建和销毁 ByteBuf 带来的性能消耗。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数配置&lt;/strong&gt; ：可配置的 I/O 线程数目和 TCP 参数等，为不同用户提供定制化的调优参数，满足不同的性能场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;队列优化&lt;/strong&gt; ：采用环形数组缓冲区，实现无锁化并发编程，代替传统的线程安全容器或锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发能力&lt;/strong&gt; ：合理使用线程安全容器、原子类等，提升系统的并发能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;降低锁竞争&lt;/strong&gt; ：关键资源的使用采用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的 CPU 资源消耗问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存泄露检测&lt;/strong&gt; ：通过引用计数器及时地释放不再被引用的对象，细粒度的内存管理降低了 GC 的频率，减少频繁 GC 带来的时延增大和 CPU 损耗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netty-的高可靠如何体现&#34;&gt;Netty 的高可靠如何体现？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;链路有效性检测&lt;/strong&gt;：由于长连接不需要每次发送消息都创建链路，也不需要在消息完成交互时关闭链路，因此相对于短连接性能更高。为了保证长连接的链路有效性，往往需要通过心跳机制周期性地进行链路检测。使用心跳机制的原因是，避免在系统空闲时因网络闪断而断开连接，之后又遇到海量业务冲击导致消息积压无法处理。为了解决这个问题，需要周期性地对链路进行有效性检测，一旦发现问题，可以及时关闭链路，重建 TCP 连接。为了支持心跳，Netty 提供了两种链路空闲检测机制：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读空闲超时机制：连续 T 周期没有消息可读时，发送心跳消息，进行链路检测。如果连续 N 个周期没有读取到心跳消息，可以主动关闭链路，重建连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写空闲超时机制：连续 T 周期没有消息需要发送时，发送心跳消息，进行链路检测。如果连续 N 个周期没有读取对方发回的心跳消息，可以主动关闭链路，重建连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/ChannelHandler-5-idle/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— ChannelHandler（五）之 IdleStateHandler》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;内存保护机制&lt;/strong&gt;：Netty 提供多种机制对内存进行保护，包括以下几个方面：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过对象引用计数器对 ByteBuf 进行细粒度的内存申请和释放，对非法的对象引用进行检测和保护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可设置的内存容量上限，包括 ByteBuf、线程池线程数等，避免异常请求耗光内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;优雅停机&lt;/strong&gt;：优雅停机功能指的是当系统推出时，JVM 通过注册的 Shutdown Hook 拦截到退出信号量，然后执行推出操作，释放相关模块的资源占用，将缓冲区的消息处理完成或清空，将待刷新的数据持久化到磁盘和数据库中，等到资源回收和缓冲区消息处理完成之后，再退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/EventLoop-8-EventLoop-shutdown/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— EventLoop（八）之 EventLoop 优雅关闭》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netty-的可扩展如何体现&#34;&gt;Netty 的可扩展如何体现？&lt;/h2&gt;
&lt;p&gt;可定制、易扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;责任链模式&lt;/strong&gt; ：ChannelPipeline 基于责任链模式开发，便于业务逻辑的拦截、定制和扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基于接口的开发&lt;/strong&gt; ：关键的类库都提供了接口或抽象类，便于用户自定义实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供大量的工厂类&lt;/strong&gt; ：通过重载这些工厂类，可以按需创建出用户需要的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供大量系统参数&lt;/strong&gt; ：供用户按需设置，增强系统的场景定制性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;艿艿：说个题外话。&lt;/p&gt;
&lt;p&gt;实际上，任何的技术的研究，我们都可以去思考，它的高性能是怎么体现的，它的可靠性是怎么体现的，它的可拓展是怎么体现的。&lt;/p&gt;
&lt;p&gt;当然，因为很多时候有近义词，所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高性能 =&amp;gt; 高并发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可靠性 =&amp;gt; 高可用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可拓展 =&amp;gt; 高拓展&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如说，MySQL 如何实现高性能，MySQL 如何搭建高可用，😈 MySQL 如何做拓展貌似暂时没，哈哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;简单介绍-netty-的核心组件&#34;&gt;简单介绍 Netty 的核心组件？&lt;/h2&gt;
&lt;p&gt;Netty 有如下六个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bootstrap &amp;amp; ServerBootstrap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Channel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ChannelFuture&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EventLoop &amp;amp; EventLoopGroup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ChannelHandler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ChannelPipeline&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细的，请直接阅读 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/intro-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— Netty 简介（二）之核心组件》&lt;/a&gt; 一文。&lt;/p&gt;
&lt;h2 id=&#34;说说-netty-的逻辑架构&#34;&gt;说说 Netty 的逻辑架构？&lt;/h2&gt;
&lt;p&gt;Netty 采用了典型的&lt;strong&gt;三层网络架构&lt;/strong&gt;进行设计和开发，其逻辑架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/85d98e3cb0e6e39f80d02234e039a4dd&#34;  title=&#34;Netty 逻辑架构图&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;http://static.iocoder.cn/85d98e3cb0e6e39f80d02234e039a4dd&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Netty 逻辑架构图&#34;
	
	
&gt;&lt;/a&gt;Netty 逻辑架构图&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;艿艿：注意，这个图是自下向上看。哈哈哈~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reactor 通信调度层&lt;/strong&gt;：由一系列辅助类组成，包括 Reactor 线程 NioEventLoop 及其父类，NioSocketChannel 和 NioServerSocketChannel 等等。该层的职责就是监听网络的读写和连接操作，负责将网络层的数据读到内存缓冲区，然后触发各自网络事件，例如连接创建、连接激活、读事件、写事件等。将这些事件触发到 pipeline 中，由 pipeline 管理的职责链来进行后续的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;职责链 ChannelPipeline&lt;/strong&gt;：负责事件在职责链中的有序传播，以及负责动态地编排职责链。职责链可以选择监听和处理自己关心的事件，拦截处理和向后传播事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑编排层&lt;/strong&gt;：业务逻辑编排层通常有两类，一类是纯粹的业务逻辑编排，一类是应用层协议插件，用于特定协议相关的会话和链路管理。由于应用层协议栈往往是开发一次到处运行，并且变动较小，故而将应用协议到 POJO 的转变和上层业务放到不同的 ChannelHandler 中，就可以实现协议层和业务逻辑层的隔离，实现架构层面的分层隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是-reactor-模型&#34;&gt;什么是 Reactor 模型？&lt;/h2&gt;
&lt;p&gt;直接阅读 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/EventLoop-1-Reactor-Model/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— EventLoop（一）之 Reactor 模型》&lt;/a&gt; 一文。&lt;/p&gt;
&lt;p&gt;认真仔细读，这是一个高频面试题。&lt;/p&gt;
&lt;h2 id=&#34;请介绍-netty-的线程模型&#34;&gt;请介绍 Netty 的线程模型？&lt;/h2&gt;
&lt;p&gt;还是阅读 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/EventLoop-1-Reactor-Model/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— EventLoop（一）之 Reactor 模型》&lt;/a&gt; 一文。&lt;/p&gt;
&lt;p&gt;认真仔细读，这真的真的真的是一个高频面试题。&lt;/p&gt;
&lt;h2 id=&#34;什么是业务线程池&#34;&gt;什么是业务线程池？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/Interview/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;「什么是 Reactor 模型？」&lt;/a&gt; 问题中，无论是那种类型的 Reactor 模型，都需要在 Reactor 所在的线程中，进行读写操作。那么此时就会有一个问题，如果我们读取到数据，需要进行业务逻辑处理，并且这个业务逻辑需要对数据库、缓存等等进行操作，会有什么问题呢？假设这个数据库操作需要 5 ms ，那就意味着这个 Reactor 线程在这 5 ms 无法进行注册在这个 Reactor 的 Channel 进行读写操作。也就是说，多个 Channel 的所有读写操作都变成了串行。势必，这样的效率会非常非常非常的低。&lt;/p&gt;
&lt;p&gt;🦅 &lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么怎么解决呢？创建业务线程池，将读取到的数据，提交到业务线程池中进行处理。这样，Reactor 的 Channel 就不会被阻塞，而 Channel 的所有读写操作都变成了并行了。&lt;/p&gt;
&lt;p&gt;🦅 &lt;strong&gt;案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果胖友熟悉 Dubbo 框架，就会发现 &lt;a class=&#34;link&#34; href=&#34;http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Dubbo 用户指南 —— 线程模型》&lt;/a&gt; 。😈 认真读下，可以跟面试官吹一吹啦。&lt;/p&gt;
&lt;h2 id=&#34;tcp-粘包--拆包的原因应该这么解决&#34;&gt;TCP 粘包 / 拆包的原因？应该这么解决？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP 是以流的方式来处理数据，所以会导致粘包 / 拆包。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拆包：一个完整的包可能会被 TCP 拆分成多个包进行发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;粘包：也可能把小的封装成一个大的数据包发送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生&lt;strong&gt;拆包&lt;/strong&gt;现象。而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生&lt;strong&gt;粘包&lt;/strong&gt;现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行&lt;strong&gt;拆包&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太网帧的 payload（净荷）大于 MTU（默认为 1500 字节）进行 IP 分片&lt;strong&gt;拆包&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生&lt;strong&gt;粘包&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Netty 中，提供了多个 Decoder 解析类，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;① FixedLengthFrameDecoder ，基于&lt;strong&gt;固定长度&lt;/strong&gt;消息进行粘包拆包处理的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;② LengthFieldBasedFrameDecoder ，基于&lt;strong&gt;消息头指定消息长度&lt;/strong&gt;进行粘包拆包处理的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;③ LineBasedFrameDecoder ，基于&lt;strong&gt;换行&lt;/strong&gt;来进行消息粘包拆包处理的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;④ DelimiterBasedFrameDecoder ，基于&lt;strong&gt;指定消息边界方式&lt;/strong&gt;进行粘包拆包处理的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，上述四个 FrameDecoder 实现可以进行规整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;① 是 ② 的特例，&lt;strong&gt;固定长度&lt;/strong&gt;是&lt;strong&gt;消息头指定消息长度&lt;/strong&gt;的一种形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;③ 是 ④ 的特例，&lt;strong&gt;换行&lt;/strong&gt;是于&lt;strong&gt;指定消息边界方式&lt;/strong&gt;的一种形式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感兴趣的胖友，可以看看如下两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/Codec-1-1-ByteToMessageDecoder-core-impl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（一）Cumulator》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/Codec-1-2-ByteToMessageDecoder-FrameDecoder/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Codec 之 ByteToMessageDecoder（二）FrameDecoder》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;了解哪几种序列化协议&#34;&gt;了解哪几种序列化协议？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;序列化（编码），是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反序列化（解码），则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;选型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在选择序列化协议的选择，主要考虑以下三个因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;序列化后的&lt;strong&gt;字节大小&lt;/strong&gt;。更少的字节数，可以减少网络带宽、磁盘的占用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;序列化的&lt;strong&gt;性能&lt;/strong&gt;。对 CPU、内存资源占用情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否支持&lt;strong&gt;跨语言&lt;/strong&gt;。例如，异构系统的对接和开发语言切换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;🦅 &lt;strong&gt;方案&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果对序列化工具了解不多的胖友，可能一看有这么多优缺点会比较懵逼，可以先记得有哪些序列化工具，然后在慢慢熟悉它们的优缺点。&lt;/p&gt;
&lt;p&gt;重点，还是知道【&lt;strong&gt;选型&lt;/strong&gt;】的考虑点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;【重点】Java 默认提供的序列化&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;无法跨语言；序列化后的字节大小太大；序列化的性能差。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;【重点】XML 。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：人机可读性好，可指定元素或特性的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景：当做配置文件存储数据，实时数据转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;【重点】JSON ，是一种轻量级的数据交换格式。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好。与 XML 相比，其协议比较简单，解析速度比较快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：数据的描述性比 XML 差、不适合性能要求为 ms 级别的情况、额外空间开销比较大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景（可替代 XML ）：跨防火墙访问、可调式性要求高、基于Restful API 请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;【了解】Thrift ，不仅是序列化协议，还是一个 RPC 框架。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如 HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景：分布式系统的 RPC 解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;【了解】Avro ，Hadoop 的一个子项目，解决了JSON的冗长和没有IDL的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用 RPC、支持跨编程语言实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：对于习惯于静态类型语言的用户不直观。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景：在 Hadoop 中做 Hive、Pig 和 MapReduce 的持久化数据格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;【重点】Protobuf ，将数据结构以 &lt;code&gt;.proto&lt;/code&gt; 文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO 对象和 Protobuf 相关的方法和属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++、python。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景：对性能要求高的 RPC 调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;其它&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目前，阿里 RPC 框架 Dubbo 的可选序列化协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前，阿里 RPC 框架 Dubbo 的可选序列化协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前，阿里 RPC 框架 Dubbo 的&lt;strong&gt;默认&lt;/strong&gt;序列化协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前，微博 RPC 框架 Motan 在使用它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【重点】Protostuff ，基于 Protobuf 协议，但不需要配置proto 文件，直接导包即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【了解】Jboss Marshaling ，可以直接序列化 Java 类， 无须实 &lt;code&gt;java.io.Serializable&lt;/code&gt; 接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【了解】Message Pack ，一个高效的二进制序列化格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【重点】&lt;a class=&#34;link&#34; href=&#34;https://www.oschina.net/p/hessian&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hessian&lt;/a&gt; ，采用二进制协议的轻量级 remoting on http 服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【重要】kryo ，是一个快速高效的Java对象图形序列化框架，主要特点是性能、高效和易用。该项目用来序列化对象到文件、数据库或者网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【重要】FST ，fast-serialization 是重新实现的 Java 快速对象序列化的开发包。序列化速度更快（2-10倍）、体积更小，而且兼容 JDK 原生的序列化。要求 JDK 1.7 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netty-的零拷贝实现&#34;&gt;Netty 的零拷贝实现？&lt;/h2&gt;
&lt;p&gt;Netty 的零拷贝实现，是体现在多方面的，主要如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【重点】Netty 的接收和发送 ByteBuffer 采用堆外直接内存 &lt;strong&gt;Direct Buffer&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝；使用堆内内存会多了一次内存拷贝，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Netty 创建的 ByteBuffer 类型，由 ChannelConfig 配置。而 ChannelConfig 配置的 ByteBufAllocator 默认创建 Direct Buffer 类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CompositeByteBuf&lt;/strong&gt; 类，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf ，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer 。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#addComponents(...)&lt;/code&gt; 方法，可将 header 与 body 合并为一个逻辑上的 ByteBuf 。这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的，即 CompositeByteBuf 只是逻辑上是一个整体。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;通过 &lt;strong&gt;FileRegion&lt;/strong&gt; 包装的 FileChannel 。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#tranferTo(...)&lt;/code&gt; 方法，实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel ，避免了传统通过循环 write 方式，导致的内存拷贝问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;通过 &lt;strong&gt;wrap&lt;/strong&gt; 方法, 我们可以将 &lt;code&gt;byte[]&lt;/code&gt; 数组、ByteBuf、ByteBuffer 等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;原生的-nio-存在-epoll-bug-是什么netty-是怎么解决的&#34;&gt;原生的 NIO 存在 Epoll Bug 是什么？Netty 是怎么解决的？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;Java NIO Epoll BUG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java NIO Epoll 会导致 Selector 空轮询，最终导致 CPU 100% 。&lt;/p&gt;
&lt;p&gt;官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些而已，它并没有得到根本性解决。&lt;/p&gt;
&lt;p&gt;🦅 &lt;strong&gt;Netty 解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对 Selector 的 select 操作周期进行&lt;strong&gt;统计&lt;/strong&gt;，每完成一次&lt;strong&gt;空&lt;/strong&gt;的 select 操作进行一次计数，若在某个周期内连续发生 N 次空轮询，则判断触发了 Epoll 死循环 Bug 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;艿艿：此处&lt;strong&gt;空&lt;/strong&gt;的 select 操作的定义是，select 操作执行了 0 毫秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，Netty &lt;strong&gt;重建&lt;/strong&gt; Selector 来解决。判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从旧的 Selector 上取消注册，然后重新注册到新的 Selector 上，最后将原来的 Selector 关闭。&lt;/p&gt;
&lt;h2 id=&#34;什么是-netty-空闲检测&#34;&gt;什么是 Netty 空闲检测？&lt;/h2&gt;
&lt;p&gt;在 Netty 中，提供了 IdleStateHandler 类，正如其名，空闲状态处理器，用于检测连接的读写是否处于空闲状态。如果是，则会触发 IdleStateEvent 。&lt;/p&gt;
&lt;p&gt;IdleStateHandler 目前提供三种类型的心跳检测，通过构造方法来设置。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// IdleStateHandler.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public IdleStateHandler(  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int readerIdleTimeSeconds,  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int writerIdleTimeSeconds,  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int allIdleTimeSeconds) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; this(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds,  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; TimeUnit.SECONDS);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;readerIdleTimeSeconds&lt;/code&gt; 参数：为读超时时间，即测试端一定时间内未接受到被测试端消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;writerIdleTimeSeconds&lt;/code&gt; 参数：为写超时时间，即测试端一定时间内向被测试端发送消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allIdleTimeSeconds&lt;/code&gt; 参数：为读或写超时时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;另外，我们会在网络上看到类似《IdleStateHandler 心跳机制》这样标题的文章，实际上空闲检测和心跳机制是&lt;strong&gt;两件事&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只是说，因为我们使用 IdleStateHandler 的目的，就是检测到连接处于空闲，通过心跳判断其是否还是&lt;strong&gt;有效的连接&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然说，TCP 协议层提供了 Keeplive 机制，但是该机制默认的心跳时间是 2 小时，依赖操作系统实现不够灵活。因而，我们才在应用层上，自己实现心跳机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的，我们来看看下面的问题 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/Interview/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;「Netty 如何实现重连？」&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;netty-如何实现重连&#34;&gt;Netty 如何实现重连？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端，通过 IdleStateHandler 实现定时检测是否空闲，例如说 15 秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果空闲，则向服务端发起心跳。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果多次心跳失败，则关闭和服务端的连接，然后重新发起连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端，通过 IdleStateHandler 实现定时检测客户端是否空闲，例如说 90 秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果检测到空闲，则关闭客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意，如果接收到客户端的心跳请求，要反馈一个心跳响应给客户端。通过这样的方式，使客户端知道自己心跳成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下艿艿在自己的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/YunaiV/TaroRPC&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TaroRPC&lt;/a&gt; 中提供的一个示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/YunaiV/TaroRPC/blob/master/transport/transport-netty4/src/main/java/cn/iocoder/taro/transport/netty4/NettyClient.java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NettyClient.java&lt;/a&gt; 中，设置 IdleStateHandler 和 ClientHeartbeatHandler。核心代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// NettyHandler.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.addLast(&amp;#34;idleState&amp;#34;, new IdleStateHandler(TaroConstants.TRANSPORT\_CLIENT\_IDLE, TaroConstants.TRANSPORT\_CLIENT\_IDLE, 0, TimeUnit.MILLISECONDS))  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.addLast(&amp;#34;heartbeat&amp;#34;, new ClientHeartbeatHandler())  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/YunaiV/TaroRPC/blob/master/transport/transport-netty4/src/main/java/cn/iocoder/taro/transport/netty4/NettyServer.java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NettyServer.java&lt;/a&gt; 中，设置 IdleStateHandler 和 ServerHeartbeatHandler。核心代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// NettyServer.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.addLast(&amp;#34;idleState&amp;#34;, new IdleStateHandler(0, 0, TaroConstants.TRANSPORT\_SERVER\_IDLE, TimeUnit.MILLISECONDS))  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.addLast(&amp;#34;heartbeat&amp;#34;, new ServerHeartbeatHandler())  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/YunaiV/TaroRPC/blob/master/transport/transport-netty4/src/main/java/cn/iocoder/taro/transport/netty4/heartbeat/ClientHeartbeatHandler.java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ClientHeartbeatHandler.java&lt;/a&gt; 中，碰到空闲，则发起心跳。不过，如何重连，暂时没有实现。需要考虑，重新发起连接可能会失败的情况。具体的，可以看看 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/linuu/article/details/51509847&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《一起学Netty（十四）之 Netty生产级的心跳和重连机制》&lt;/a&gt; 文章中的，ConnectionWatchdog 的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/YunaiV/TaroRPC/blob/6ce2af911ccec9ed5dc75c7f3ebda9c758272f3b/transport/transport-netty4/src/main/java/cn/iocoder/taro/transport/netty4/heartbeat/ServerHeartbeatHandler.java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ServerHeartbeatHandler.java&lt;/a&gt; 中，检测到客户端空闲，则直接关闭连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;netty-自己实现的-bytebuf-有什么优点&#34;&gt;Netty 自己实现的 ByteBuf 有什么优点？&lt;/h2&gt;
&lt;p&gt;如下是 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/ByteBuf-1-1-ByteBuf-intro/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Netty 实战》&lt;/a&gt; 对它的&lt;strong&gt;优点总&lt;/strong&gt;结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A01. 它可以被用户自定义的&lt;strong&gt;缓冲区类型&lt;/strong&gt;扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A02. 通过内置的符合缓冲区类型实现了透明的&lt;strong&gt;零拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A03. 容量可以&lt;strong&gt;按需增长&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A04. 在读和写这两种模式之间切换不需要调用 &lt;code&gt;#flip()&lt;/code&gt; 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A05. 读和写使用了&lt;strong&gt;不同的索引&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A06. 支持方法的&lt;strong&gt;链式&lt;/strong&gt;调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A07. 支持引用计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A08. 支持&lt;strong&gt;池化&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特别是第 A04 这点，相信很多胖友都被 NIO ByteBuffer 反人类的读模式和写模式给坑哭了。在 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（三）之 Buffer》&lt;/a&gt; 中，我们也吐槽过了。😈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想要进一步深入的，可以看看 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/ByteBuf-1-1-ByteBuf-intro/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（一）简介》&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;netty-为什么要实现内存管理&#34;&gt;Netty 为什么要实现内存管理？&lt;/h2&gt;
&lt;p&gt;🦅 &lt;strong&gt;老艿艿的理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Netty 中，IO 读写必定是非常频繁的操作，而考虑到更高效的网络传输性能，Direct ByteBuffer 必然是最合适的选择。但是 Direct ByteBuffer 的申请和释放是高成本的操作，那么进行&lt;strong&gt;池化&lt;/strong&gt;管理，多次重用是比较有效的方式。但是，不同于一般于我们常见的对象池、连接池等&lt;strong&gt;池化&lt;/strong&gt;的案例，ByteBuffer 是有&lt;strong&gt;大小&lt;/strong&gt;一说。又但是，申请多大的 Direct ByteBuffer 进行池化又会是一个大问题，太大会浪费内存，太小又会出现频繁的扩容和内存复制！！！所以呢，就需要有一个合适的内存管理算法，解决&lt;strong&gt;高效分配内存&lt;/strong&gt;的同时又解决&lt;strong&gt;内存碎片化&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;p&gt;🦅 &lt;strong&gt;官方的说法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FROM &lt;a class=&#34;link&#34; href=&#34;https://skyao.gitbooks.io/learning-netty/content/buffer/pooled_buffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Netty 学习笔记 —— Pooled buffer》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Netty 4.x 增加了 Pooled Buffer，实现了高性能的 buffer 池，分配策略则是结合了 buddy allocation 和 slab allocation 的 &lt;strong&gt;jemalloc&lt;/strong&gt; 变种，代码在&lt;code&gt;io.netty.buffer.PoolArena&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;官方说提供了以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;频繁分配、释放 buffer 时减少了 GC 压力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在初始化新 buffer 时减少内存带宽消耗( 初始化时不可避免的要给buffer数组赋初始值 )。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;及时的释放 direct buffer 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;🦅 &lt;strong&gt;hushi55 大佬的理解&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;C/C++ 和 java 中有个围城，城里的想出来，城外的想进去！**&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个围城就是自动内存管理！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Netty 4 buffer 介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Netty4 带来一个与众不同的特点是其 ByteBuf 的实现，相比之下，通过维护两个独立的读写指针， 要比 &lt;code&gt;io.netty.buffer.ByteBuf&lt;/code&gt; 简单不少，也会更高效一些。不过，Netty 的 ByteBuf 带给我们的最大不同，就是他不再基于传统 JVM 的 GC 模式，相反，它采用了类似于 C++ 中的 malloc/free 的机制，需要开发人员来手动管理回收与释放。从手动内存管理上升到GC，是一个历史的巨大进步， 不过，在20年后，居然有曲线的回归到了手动内存管理模式，正印证了马克思哲学观： &lt;strong&gt;社会总是在螺旋式前进的，没有永远的最好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① GC 内存管理分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;的确，就内存管理而言，GC带给我们的价值是不言而喻的，不仅大大的降低了程序员的心智包袱， 而且，也极大的减少了内存管理带来的 Crash 困扰，为函数式编程（大量的临时对象）、脚本语言编程带来了春天。 并且，高效的GC算法也让大部分情况下程序可以有更高的执行效率。 不过，也有很多的情况，可能是手工内存管理更为合适的。譬如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于类似于业务逻辑相对简单，譬如网络路由转发型应用（很多erlang应用其实是这种类型）， 但是 QPS 非常高，比如1M级，在这种情况下，在每次处理中即便产生1K的垃圾，都会导致频繁的GC产生。 在这种模式下，erlang 的按进程回收模式，或者是 C/C++ 的手工回收机制，效率更高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache 型应用，由于对象的存在周期太长，GC 基本上就变得没有价值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，理论上，尴尬的GC实际上比较适合于处理介于这 2 者之间的情况： 对象分配的频繁程度相比数据处理的时间要少得多的，但又是相对短暂的， 典型的，对于OLTP型的服务，处理能力在 1K QPS 量级，每个请求的对象分配在 10K-50K 量级， 能够在 5-10s 的时间内进行一 次younger GC ，每次GC的时间可以控制在 10ms 水平上， 这类的应用，实在是太适合 GC 行的模式了，而且结合 Java 高效的分代 GC ，简直就是一个理想搭配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Netty 4 引入了手工内存的模式，我觉得这是一大创新，这种模式甚至于会延展， 应用到 Cache 应用中。实际上，结合 JVM 的诸多优秀特性，如果用 Java 来实现一个 Redis 型 Cache、 或者 In-memory SQL Engine，或者是一个 Mongo DB，我觉得相比 C/C++ 而言，都要更简单很多。 实际上，JVM 也已经提供了打通这种技术的机制，就是 Direct Memory 和 Unsafe 对象。 基于这个基础，我们可以像 C 语言一样直接操作内存。实际上，Netty4 的 ByteBuf 也是基于这个基础的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多详细的内容，胖友可以看看 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/ByteBuf-3-1-Jemalloc-intro/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Buffer 之 Jemalloc（一）简介》&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;netty-如何实心内存管理&#34;&gt;Netty 如何实心内存管理？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这个题目，简单了解即可，如果深入，就要去看 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/categories/Netty/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Buffer》&lt;/a&gt; 相关的源码。而且，看完就忘记，比较难和复杂。&lt;/p&gt;
&lt;p&gt;当然，看懂那一刻，乐趣无穷，哈哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Netty 内存管理机制，基于 &lt;a class=&#34;link&#34; href=&#34;http://www.cnhalo.net/2016/06/13/memory-optimize/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Jemalloc&lt;/a&gt; 算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先会预申请一大块内存 &lt;strong&gt;Arena&lt;/strong&gt; ，Arena 由许多 Chunk 组成，而每个 Chunk 默认由2048个page组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Chunk&lt;/strong&gt; 通过 &lt;strong&gt;AVL&lt;/strong&gt; 树的形式组织 &lt;strong&gt;Page&lt;/strong&gt; ，每个叶子节点表示一个 Page ，而中间节点表示内存区域，节点自己记录它在整个 Arena 中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于 8k 的内存分配在 &lt;strong&gt;PoolChunkList&lt;/strong&gt; 中，而 &lt;strong&gt;PoolSubpage&lt;/strong&gt; 用于分配小于 8k 的内存，它会把一个 page 分割成多段，进行内存分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么是-netty-的内存泄露检测是如何进行实现的&#34;&gt;什么是 Netty 的内存泄露检测？是如何进行实现的？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;艿艿：这是一道比较复杂的面试题，可以挑战一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读如下两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://calvin1978.blogcn.com/articles/netty-leak.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Netty 之有效规避内存泄漏》&lt;/a&gt; 从原理层面解释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》&lt;/a&gt; 从源码层面解读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，Netty 的内存泄露检测的实现，是对 WeakReference 和 ReferenceQueue 很好的学习。之前很多胖友在看了 &lt;a class=&#34;link&#34; href=&#34;http://www.iocoder.cn/Fight/Four-reference-types-in-Java&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Java 中的四种引用类型》&lt;/a&gt; 之后，是不太理解 Java 的四种引用的具体使用场景，这不就来了么。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>netty源码分析二</title>
        <link>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/</link>
        <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/</guid>
        <description>&lt;p&gt;精尽 Netty 源码分析 —— NIO 基础（二）之 Channel&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;概述
在 Java NIO 中，基本上所有的 IO 操作都是从 Channel 开始。数据可以从 Channel 读取到 Buffer 中，也可以从 Buffer 写到 Channel 中。如下图所示：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer &amp;lt;=&amp;gt; Channel
Buffer &amp;lt;=&amp;gt; Channel&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;NIO Channel 对比 Java Stream
NIO Channel 类似 Java Stream ，但又有几点不同：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于同一个 Channel ，我们可以从它读取数据，也可以向它写入数据。而对于同一个 Stream ，通畅要么只能读，要么只能写，二选一( 有些文章也描述成“单向”，也是这个意思 )。
Channel 可以非阻塞的读写 IO 操作，而 Stream 只能阻塞的读写 IO 操作。
Channel 必须配合 Buffer 使用，总是先读取到一个 Buffer 中，又或者是向一个 Buffer 写入。也就是说，我们无法绕过 Buffer ，直接向 Channel 写入数据。
3. Channel 的实现
Channel 在 Java 中，作为一个接口，java.nio.channels.Channel ，定义了 IO 操作的连接与关闭。代码如下：&lt;/p&gt;
&lt;p&gt;public interface Channel extends Closeable {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 判断此通道是否处于打开状态。 
 */
public boolean isOpen();

/**
 *关闭此通道。
 */
public void close() throws IOException;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
Channel 有非常多的实现类，最为重要的四个 Channel 实现类如下：&lt;/p&gt;
&lt;p&gt;SocketChannel ：一个客户端用来发起 TCP 的 Channel 。
ServerSocketChannel ：一个服务端用来监听新进来的连接的 TCP 的 Channel 。对于每一个新进来的连接，都会创建一个对应的 SocketChannel 。
DatagramChannel ：通过 UDP 读写数据。
FileChannel ：从文件中，读写数据。
老艿艿：因为 《Java NIO 系列教程》 对上述的 Channel 解释的非常不错，我就直接引用啦。&lt;/p&gt;
&lt;p&gt;我们在使用 Netty 时，主要使用 TCP 协议，所以胖友可以只看 「3.2 SocketChannel」 和 「3.1 ServerSocketChannel」 。&lt;/p&gt;
&lt;p&gt;3.1 ServerSocketChannel
《Java NIO系列教程（九） ServerSocketChannel》&lt;/p&gt;
&lt;p&gt;3.2 SocketChannel
《Java NIO 系列教程（八） SocketChannel》&lt;/p&gt;
&lt;p&gt;3.3 DatagramChannel
《Java NIO系列教程（十） Java NIO DatagramChannel》&lt;/p&gt;
&lt;p&gt;3.4 FileChannel
《Java NIO系列教程（七） FileChannel》&lt;/p&gt;
</description>
        </item>
        <item>
        <title>netty源码分析三</title>
        <link>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/</link>
        <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/</guid>
        <description>&lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;一个 Buffer ，本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。通过将这块内存封装成 NIO Buffer 对象，并提供了一组常用的方法，方便我们对该块内存的读写。&lt;/p&gt;
&lt;p&gt;Buffer 在 &lt;code&gt;java.nio&lt;/code&gt; 包中实现，被定义成&lt;strong&gt;抽象类&lt;/strong&gt;，从而实现一组常用的方法。整体类图如下：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/images/Netty/2018_02_10/01.png&#34;  title=&#34;类图&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2018_02_10/01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;类图&#34;
	
	
&gt;&lt;/a&gt;类图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们可以将 Buffer 理解为&lt;strong&gt;一个数组的封装&lt;/strong&gt;，例如 IntBuffer、CharBuffer、ByteBuffer 等分别对应 &lt;code&gt;int[]&lt;/code&gt;、&lt;code&gt;char[]&lt;/code&gt;、&lt;code&gt;byte[]&lt;/code&gt; 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MappedByteBuffer 用于实现内存映射文件，不是本文关注的重点。因此，感兴趣的胖友，可以自己 Google 了解，还是蛮有趣的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer2-e59fbae69cace5b19ee680a7-2-基本属性2-基本属性&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#2-%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7&#34;  title=&#34;2. 基本属性&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2. 基本属性&lt;/h1&gt;
&lt;p&gt;Buffer 中有 &lt;strong&gt;4&lt;/strong&gt; 个非常重要的属性：&lt;code&gt;capacity&lt;/code&gt;、&lt;code&gt;limit&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;、&lt;code&gt;mark&lt;/code&gt; 。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract class Buffer {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Invariants: mark &amp;lt;= position &amp;lt;= limit &amp;lt;= capacity  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; private int mark = -1;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; private int position = 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; private int limit;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; private int capacity;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // Used only by direct buffers  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // NOTE: hoisted here for speed in JNI GetDirectBufferAddress  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; long address;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Buffer(int mark, int pos, int lim, int cap) {       // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (cap &amp;lt; 0)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IllegalArgumentException(&amp;#34;Negative capacity: &amp;#34; \+ cap);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; this.capacity = cap;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; limit(lim);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position(pos);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (mark &amp;gt;= 0) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (mark &amp;gt; pos)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IllegalArgumentException(&amp;#34;mark &amp;gt; position: (&amp;#34;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; \+ mark + &amp;#34; \&amp;gt; &amp;#34; \+ pos + &amp;#34;)&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; this.mark = mark;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // ... 省略具体方法的代码  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;capacity&lt;/code&gt; 属性，容量，Buffer 能容纳的数据元素的&lt;strong&gt;最大值&lt;/strong&gt;。这一容量在 Buffer 创建时被赋值，并且&lt;strong&gt;永远不能被修改&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buffer 分成&lt;strong&gt;写模式&lt;/strong&gt;和&lt;strong&gt;读模式&lt;/strong&gt;两种情况。如下图所示：&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/images/Netty/2018_02_10/02.png&#34;  title=&#34;写模式 v.s. 读模式&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2018_02_10/02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;写模式 v.s. 读模式&#34;
	
	
&gt;&lt;/a&gt;写模式 v.s. 读模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从图中，我们可以看到，两种模式下，&lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;limit&lt;/code&gt; 属性分别代表不同的含义。下面，我们来分别看看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;position&lt;/code&gt; 属性，位置，初始值为 0 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写&lt;/strong&gt;模式下，每往 Buffer 中写入一个值，&lt;code&gt;position&lt;/code&gt; 就自动加 1 ，代表下一次的写入位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读&lt;/strong&gt;模式下，每从 Buffer 中读取一个值，&lt;code&gt;position&lt;/code&gt; 就自动加 1 ，代表下一次的读取位置。( &lt;em&gt;和写模式类似&lt;/em&gt; )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limit&lt;/code&gt; 属性，上限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写&lt;/strong&gt;模式下，代表最大能写入的数据上限位置，这个时候 &lt;code&gt;limit&lt;/code&gt; 等于 &lt;code&gt;capacity&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读&lt;/strong&gt;模式下，在 Buffer 完成所有数据写入后，通过调用 &lt;code&gt;#flip()&lt;/code&gt; 方法，切换到&lt;strong&gt;读&lt;/strong&gt;模式。此时，&lt;code&gt;limit&lt;/code&gt; 等于 Buffer 中实际的数据大小。因为 Buffer 不一定被写满，所以不能使用 &lt;code&gt;capacity&lt;/code&gt; 作为实际的数据大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mark&lt;/code&gt; 属性，标记，通过 &lt;code&gt;#mark()&lt;/code&gt; 方法，记录当前 &lt;code&gt;position&lt;/code&gt; ；通过 &lt;code&gt;reset()&lt;/code&gt; 方法，恢复 &lt;code&gt;position&lt;/code&gt; 为标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写&lt;/strong&gt;模式下，标记上一次写位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读&lt;/strong&gt;模式下，标记上一次读位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从代码注释上，我们可以看到，四个属性总是遵循如下大小关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mark &amp;lt;= position &amp;lt;= limit &amp;lt;= capacity  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;写到此处，忍不住吐槽了下，Buffer 的读模式和写模式，我认为是有一点“&lt;strong&gt;糟糕&lt;/strong&gt;”。相信大多数人在理解的时候，都会开始一脸懵逼的状态。相比较来说，Netty 的 ByteBuf 就&lt;strong&gt;优雅&lt;/strong&gt;的非常多，基本属性设计如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0 &amp;lt;= readerIndex &amp;lt;= writerIndex &amp;lt;= capacity  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;readerIndex&lt;/code&gt; 和 &lt;code&gt;writerIndex&lt;/code&gt; 两个属性，避免出现读模式和写模式的切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer3-e5889be5bbba-buffer-3-创建-buffer3-创建-buffer&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#3-%E5%88%9B%E5%BB%BA-Buffer&#34;  title=&#34;3. 创建 Buffer&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3. 创建 Buffer&lt;/h1&gt;
&lt;p&gt;① 每个 Buffer 实现类，都提供了 &lt;code&gt;#allocate(int capacity)&lt;/code&gt; 静态方法，帮助我们快速&lt;strong&gt;实例化&lt;/strong&gt;一个 Buffer 对象。以 ByteBuffer 举例子，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ByteBuffer.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static ByteBuffer allocate(int capacity) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (capacity &amp;lt; 0)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IllegalArgumentException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return new HeapByteBuffer(capacity, capacity);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;ByteBuffer 实际是个抽象类，返回的是它的&lt;strong&gt;基于堆内( Non-Direct )内存&lt;/strong&gt;的实现类 HeapByteBuffer 的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;② 每个 Buffer 实现类，都提供了 &lt;code&gt;#wrap(array)&lt;/code&gt; 静态方法，帮助我们将其对应的数组&lt;strong&gt;包装&lt;/strong&gt;成一个 Buffer 对象。还是以 ByteBuffer 举例子，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ByteBuffer.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static ByteBuffer wrap(byte\[\] array, int offset, int length){  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; try {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return new HeapByteBuffer(array, offset, length);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } catch (IllegalArgumentException x) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IndexOutOfBoundsException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static ByteBuffer wrap(byte\[\] array) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return wrap(array, 0, array.length);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;和 &lt;code&gt;#allocate(int capacity)&lt;/code&gt; 静态方法&lt;strong&gt;一样&lt;/strong&gt;，返回的也是 HeapByteBuffer 的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;③ 每个 Buffer 实现类，都提供了 &lt;code&gt;#allocateDirect(int capacity)&lt;/code&gt; 静态方法，帮助我们快速&lt;strong&gt;实例化&lt;/strong&gt;一个 Buffer 对象。以 ByteBuffer 举例子，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ByteBuffer.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static ByteBuffer allocateDirect(int capacity) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return new DirectByteBuffer(capacity);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;和 &lt;code&gt;#allocate(int capacity)&lt;/code&gt; 静态方法&lt;strong&gt;不一样&lt;/strong&gt;，返回的是它的&lt;strong&gt;基于堆外( Direct )内存&lt;/strong&gt;的实现类 DirectByteBuffer 的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-3-buffer3-1-e585b3e4ba8e-direct-buffer-e5928c-non-direct-buffer-e79a84e58cbae588ab-31-关于-direct-buffer-和-non-direct-buffer-的区别31-关于-direct-buffer-和-non-direct-buffer-的区别&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#3-1-%E5%85%B3%E4%BA%8E-Direct-Buffer-%E5%92%8C-Non-Direct-Buffer-%E7%9A%84%E5%8C%BA%E5%88%AB&#34;  title=&#34;3.1 关于 Direct Buffer 和 Non-Direct Buffer 的区别&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.1 关于 Direct Buffer 和 Non-Direct Buffer 的区别&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;FROM &lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000006824155&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Java NIO 的前生今世 之三 NIO Buffer 详解》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Direct Buffer:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Non-Direct Buffer:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者之前研究 JVM 内存时，也整理过一个脑图，感兴趣的胖友可以下载：&lt;a class=&#34;link&#34; href=&#34;http://static.iocoder.cn/Java%E5%86%85%E5%AD%98.xmind&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;传送门&lt;/a&gt; 。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer4-e59091-buffer-e58699e585a5e695b0e68dae-4-向-buffer-写入数据4-向-buffer-写入数据&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#4-%E5%90%91-Buffer-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE&#34;  title=&#34;4. 向 Buffer 写入数据&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;4. 向 Buffer 写入数据&lt;/h1&gt;
&lt;p&gt;每个 Buffer 实现类，都提供了 &lt;code&gt;#put(...)&lt;/code&gt; 方法，向 Buffer 写入数据。以 ByteBuffer 举例子，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 写入 byte  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract ByteBuffer put(byte b);   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract ByteBuffer put(int index, byte b);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 写入 byte 数组  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final ByteBuffer put(byte\[\] src) { ... }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public ByteBuffer put(byte\[\] src, int offset, int length) {...}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ... 省略，还有其他 put 方法  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对于 Buffer 来说，有一个非常重要的操作就是，我们要讲来自 Channel 的数据写入到 Buffer 中。在系统层面上，这个操作我们称为&lt;strong&gt;读操作&lt;/strong&gt;，因为数据是从外部( 文件或者网络等 )读取到内存中。示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int num = channel.read(buffer);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上述方法会返回从 Channel 中写入到 Buffer 的数据大小。对应方法的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public interface ReadableByteChannel extends Channel {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; public int read(ByteBuffer dst) throws IOException;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer5-e4bb8e-buffer-e8afbbe58f96e695b0e68dae-5-从-buffer-读取数据5-从-buffer-读取数据&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#5-%E4%BB%8E-Buffer-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE&#34;  title=&#34;5. 从 Buffer 读取数据&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;5. 从 Buffer 读取数据&lt;/h1&gt;
&lt;p&gt;每个 Buffer 实现类，都提供了 &lt;code&gt;#get(...)&lt;/code&gt; 方法，从 Buffer 读取数据。以 ByteBuffer 举例子，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 读取 byte  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract byte get();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract byte get(int index);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 读取 byte 数组  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public ByteBuffer get(byte\[\] dst, int offset, int length) {...}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public ByteBuffer get(byte\[\] dst) {...}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ... 省略，还有其他 get 方法  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对于 Buffer 来说，还有一个非常重要的操作就是，我们要讲来向 Channel 的写入 Buffer 中的数据。在系统层面上，这个操作我们称为&lt;strong&gt;写操作&lt;/strong&gt;，因为数据是从内存中写入到外部( 文件或者网络等 )。示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int num = channel.write(buffer);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上述方法会返回向 Channel 中写入 Buffer 的数据大小。对应方法的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public interface WritableByteChannel extends Channel {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; public int write(ByteBuffer src) throws IOException;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer6-rewind-v-s-flip-v-s-clear-6-rewind-vs-flip-vs-clear6-rewind-vs-flip-vs-clear&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#6-rewind-v-s-flip-v-s-clear&#34;  title=&#34;6. rewind() v.s. flip() v.s. clear()&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;6. rewind() v.s. flip() v.s. clear()&lt;/h1&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-3-buffer6-1-flip-61-flip61-flip&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#6-1-flip&#34;  title=&#34;6.1 flip&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;6.1 flip&lt;/h2&gt;
&lt;p&gt;如果要读取 Buffer 中的数据，需要切换模式，&lt;strong&gt;从写模式切换到读模式&lt;/strong&gt;。对应的为 &lt;code&gt;#flip()&lt;/code&gt; 方法，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer flip() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; limit = position; // 设置读取上限  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position = 0; // 重置 position  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; mark = -1; // 清空 mark  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用示例，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;buf.put(magic);    // Prepend header  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;in.read(buf);      // Read data into rest of buffer  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;buf.flip();        // Flip buffer  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.write(buf);    // Write header + data to channel  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;httpsvipiocodercnnettynio-3-buffer6-2-rewind-62-rewind62-rewind&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#6-2-rewind&#34;  title=&#34;6.2 rewind&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;6.2 rewind&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#rewind()&lt;/code&gt; 方法，可以&lt;strong&gt;重置&lt;/strong&gt; &lt;code&gt;position&lt;/code&gt; 的值为 0 。因此，我们可以重新&lt;strong&gt;读取和写入&lt;/strong&gt; Buffer 了。&lt;/p&gt;
&lt;p&gt;大多数情况下，该方法主要针对于&lt;strong&gt;读模式&lt;/strong&gt;，所以可以翻译为“倒带”。也就是说，和我们当年的磁带倒回去是一个意思。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer rewind() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position = 0; // 重置 position  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; mark = -1; // 清空 mark  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;从代码上，和 &lt;code&gt;#flip()&lt;/code&gt; 相比，非常类似，除了少了第一行的 &lt;code&gt;limit = position&lt;/code&gt; 的代码块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用示例，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.write(buf);    // Write remaining data  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;buf.rewind();      // Rewind buffer  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;buf.get(array);    // Copy data into array  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;httpsvipiocodercnnettynio-3-buffer6-3-clear-63-clear63-clear&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#6-3-clear&#34;  title=&#34;6.3 clear&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;6.3 clear&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#clear()&lt;/code&gt; 方法，可以“&lt;strong&gt;重置&lt;/strong&gt;” Buffer 的数据。因此，我们可以重新&lt;strong&gt;读取和写入&lt;/strong&gt; Buffer 了。&lt;/p&gt;
&lt;p&gt;大多数情况下，该方法主要针对于&lt;strong&gt;写模式&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer clear() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position = 0; // 重置 position  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; limit = capacity; // 恢复 limit 为 capacity  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; mark = -1; // 清空 mark  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从源码上，我们可以看出，Buffer 的数据实际并未清理掉，所以使用时需要注意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读模式下，尽量不要调用 &lt;code&gt;#clear()&lt;/code&gt; 方法，因为 &lt;code&gt;limit&lt;/code&gt; 可能会被错误的赋值为 &lt;code&gt;capacity&lt;/code&gt; 。相比来说，调用 &lt;code&gt;#rewind()&lt;/code&gt; 更合理，如果有重读的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用示例，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;buf.clear();     // Prepare buffer for reading  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;in.read(buf);    // Read data  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer7-mark-e690ade9858d-reset-7-mark-搭配-reset7-mark-搭配-reset&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#7-mark-%E6%90%AD%E9%85%8D-reset&#34;  title=&#34;7. mark() 搭配 reset()&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;7. mark() 搭配 reset()&lt;/h1&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-3-buffer7-1-mark-71-mark71-mark&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#7-1-mark&#34;  title=&#34;7.1 mark&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;7.1 mark&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#mark()&lt;/code&gt; 方法，保存当前的 &lt;code&gt;position&lt;/code&gt; 到 &lt;code&gt;mark&lt;/code&gt; 中。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer mark() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; mark = position;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;httpsvipiocodercnnettynio-3-buffer7-2-reset-72-reset72-reset&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#7-2-reset&#34;  title=&#34;7.2 reset&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;7.2 reset&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;#reset()&lt;/code&gt; 方法，恢复当前的 &lt;code&gt;postion&lt;/code&gt; 为 &lt;code&gt;mark&lt;/code&gt; 。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer reset() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int m = mark;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (m &amp;lt; 0)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new InvalidMarkException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position = m;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;httpsvipiocodercnnettynio-3-buffer8-e585b6e5ae83e696b9e6b395-8-其它方法8-其它方法&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-3-buffer/#8-%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95&#34;  title=&#34;8. 其它方法&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;8. 其它方法&lt;/h1&gt;
&lt;p&gt;Buffer 中还有其它方法，比较简单，所以胖友自己研究噢。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== capacity ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final int capacity() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return capacity;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== position ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final int position() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return position;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer position(int newPosition) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if ((newPosition &amp;gt; limit) || (newPosition &amp;lt; 0))  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IllegalArgumentException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position = newPosition;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (mark &amp;gt; position) mark = -1;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== limit ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final int limit() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return limit;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final Buffer limit(int newLimit) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if ((newLimit &amp;gt; capacity) || (newLimit &amp;lt; 0))  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IllegalArgumentException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; limit = newLimit;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (position &amp;gt; limit) position = limit;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (mark &amp;gt; limit) mark = -1;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return this;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== mark ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int markValue() {                             // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return mark;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final void discardMark() {                          // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; mark = -1;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== 数组相关 ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final int remaining() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return limit - position;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final boolean hasRemaining() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return position &amp;lt; limit;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract boolean hasArray();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract Object array();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract int arrayOffset();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract boolean isDirect();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== 下一个读 / 写 position ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int nextGetIndex() {                          // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (position &amp;gt;= limit)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new BufferUnderflowException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return position++;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int nextGetIndex(int nb) {                    // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (limit - position &amp;lt; nb)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new BufferUnderflowException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int p = position;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position += nb;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return p;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int nextPutIndex() {                          // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (position &amp;gt;= limit)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new BufferOverflowException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return position++;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int nextPutIndex(int nb) {                    // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (limit - position &amp;lt; nb)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new BufferOverflowException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int p = position;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position += nb;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return p;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int checkIndex(int i) {                       // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if ((i &amp;lt; 0) || (i &amp;gt;= limit))  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IndexOutOfBoundsException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return i;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final int checkIndex(int i, int nb) {               // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if ((i &amp;lt; 0) || (nb &amp;gt; limit - i))  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IndexOutOfBoundsException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return i;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// ========== 其它方法 ==========  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final void truncate() {                             // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; mark = -1;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; position = 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; limit = 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; capacity = 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;static void checkBounds(int off, int len, int size) { // package-private  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if ((off | len | (off + len) | (size - (off + len))) &amp;lt; 0)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new IndexOutOfBoundsException();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>netty源码分析四</title>
        <link>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B/</link>
        <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B/</guid>
        <description>&lt;p&gt;Selector ， 一般称为&lt;strong&gt;选择器&lt;/strong&gt;。它是 Java NIO 核心组件中的一个，用于轮询一个或多个 NIO Channel 的状态是否处于可读、可写。如此，一个线程就可以管理多个 Channel ，也就说可以管理多个网络连接。也因此，Selector 也被称为&lt;strong&gt;多路复用器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么 Selector 是如何轮询的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，需要将 Channel 注册到 Selector 中，这样 Selector 才知道哪些 Channel 是它需要管理的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之后，Selector 会不断地轮询注册在其上的 Channel 。如果某个 Channel 上面发生了读或者写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是一个 Selector 管理三个 Channel 的示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2018_02_15/01.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Selector &amp;lt;=&amp;gt; Channel&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector2-e4bc98e7bcbae782b9-2-优缺点2-优缺点&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#2-%E4%BC%98%E7%BC%BA%E7%82%B9&#34;  title=&#34;2. 优缺点&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2. 优缺点&lt;/h1&gt;
&lt;p&gt;① &lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用一个线程&lt;strong&gt;能够&lt;/strong&gt;处理多个 Channel 的优点是，只需要更少的线程来处理 Channel 。事实上，可以使用一个线程处理所有的 Channel 。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源( 例如 CPU、内存 )。因此，使用的线程越少越好。&lt;/p&gt;
&lt;p&gt;② &lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为在一个线程中使用了多个 Channel ，因此会造成每个 Channel 处理效率的降低。&lt;/p&gt;
&lt;p&gt;当然，Netty 在设计实现上，通过 n 个线程处理多个 Channel ，从而很好的解决了这样的缺点。其中，n 的指的是有限的线程数，默认情况下为 CPU * 2 。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector3-selector-e7b1bbe59bbe-3-selector-类图3-selector-类图&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#3-Selector-%E7%B1%BB%E5%9B%BE&#34;  title=&#34;3. Selector 类图&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3. Selector 类图&lt;/h1&gt;
&lt;p&gt;Selector 在 &lt;code&gt;java.nio&lt;/code&gt; 包中，被定义成&lt;strong&gt;抽象类&lt;/strong&gt;，整体实现类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://static.iocoder.cn/images/Netty/2018_02_15/02.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Selector 类图&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Selector 的实现不是本文的重点，感兴趣的胖友可以看看占小狼的 &lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/0d497fe5484a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《深入浅出NIO之Selector实现原理》&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector3-e5889be5bbba-selector-3-创建-selector3-创建-selector&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#3-%E5%88%9B%E5%BB%BA-Selector&#34;  title=&#34;3. 创建 Selector&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3. 创建 Selector&lt;/h1&gt;
&lt;p&gt;通过 &lt;code&gt;#open()&lt;/code&gt; 方法，我们可以创建一个 Selector 对象。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Selector selector = Selector.open();  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector4-e6b3a8e5868c-chanel-e588b0-selector-e4b8ad-4-注册-chanel-到-selector-中4-注册-chanel-到-selector-中&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#4-%E6%B3%A8%E5%86%8C-Chanel-%E5%88%B0-Selector-%E4%B8%AD&#34;  title=&#34;4. 注册 Chanel 到 Selector 中&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;4. 注册 Chanel 到 Selector 中&lt;/h1&gt;
&lt;p&gt;为了让 Selector 能够管理 Channel ，我们需要将 Channel 注册到 Selector 中。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.configureBlocking(false); // &amp;lt;1&amp;gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SelectionKey key = channel.register(selector, SelectionKey.OP_READ);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，如果一个 Channel 要注册到 Selector 中，那么该 Channel 必须是&lt;strong&gt;非阻塞&lt;/strong&gt;，所以 &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; 处的 &lt;code&gt;channel.configureBlocking(false);&lt;/code&gt; 代码块。也因此，FileChannel 是不能够注册到 Channel 中的，因为它是&lt;strong&gt;阻塞&lt;/strong&gt;的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;#register(Selector selector, int interestSet)&lt;/code&gt; 方法的&lt;strong&gt;第二个参数&lt;/strong&gt;，表示一个“interest 集合”，意思是通过 Selector 监听 Channel 时，对&lt;strong&gt;哪些&lt;/strong&gt;( 可以是多个 )事件感兴趣。可以监听四种不同类型的事件：&lt;/p&gt;
&lt;p&gt;Channel 触发了一个事件，意思是该事件已经就绪：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Connect ：连接完成事件( TCP 连接 )，仅适用于客户端，对应 &lt;code&gt;SelectionKey.OP_CONNECT&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Accept ：接受新连接事件，仅适用于服务端，对应 &lt;code&gt;SelectionKey.OP_ACCEPT&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read ：读事件，适用于两端，对应 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; ，表示 Buffer 可读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write ：写时间，适用于两端，对应 &lt;code&gt;SelectionKey.OP_WRITE&lt;/code&gt; ，表示 Buffer 可写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 Client Channel Channel 成功连接到另一个服务器，称为“连接就绪”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 Server Socket Channel 准备好接收新进入的连接，称为“接收就绪”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个有数据可读的 Channel ，可以说是“读就绪”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个等待写数据的 Channel ，可以说是“写就绪”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;因为 Selector 可以对 Channel 的&lt;strong&gt;多个&lt;/strong&gt;事件感兴趣，所以在我们想要注册 Channel 的多个事件到 Selector 中时，可以使用&lt;strong&gt;或运算&lt;/strong&gt; &lt;code&gt;|&lt;/code&gt; 来组合多个事件。示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int interestSet = SelectionKey.OP\_READ | SelectionKey.OP\_WRITE;  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;实际使用时，我们会有&lt;strong&gt;改变&lt;/strong&gt; Selector 对 Channel 感兴趣的事件集合，可以通过再次调用 &lt;code&gt;#register(Selector selector, int interestSet)&lt;/code&gt; 方法来进行变更。示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.register(selector, SelectionKey.OP_READ);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.register(selector, SelectionKey.OP\_READ | SelectionKey.OP\_WRITE);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始时，Selector 仅对 Channel 的 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; 事件感兴趣。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改后，Selector 仅对 Channel 的 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; 和 &lt;code&gt;SelectionKey.OP_WRITE)&lt;/code&gt; 事件&lt;strong&gt;都&lt;/strong&gt;感兴趣。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector5-selectionkey-e7b1bb-5-selectionkey-类5-selectionkey-类&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#5-SelectionKey-%E7%B1%BB&#34;  title=&#34;5. SelectionKey 类&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;5. SelectionKey 类&lt;/h1&gt;
&lt;p&gt;上一小节, 当我们调用 Channel 的 &lt;code&gt;#register(...)&lt;/code&gt; 方法，向 Selector 注册一个 Channel 后，会返回一个 SelectionKey 对象。那么 SelectionKey 是什么呢？SelectionKey 在 &lt;code&gt;java.nio.channels&lt;/code&gt; 包下，被定义成一个&lt;strong&gt;抽象类&lt;/strong&gt;，表示一个 Channel 和一个 Selector 的注册关系，包含如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;interest set ：感兴趣的事件集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ready set ：就绪的事件集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Channel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Selector&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attachment ：_可选的_附加对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-4-selector5-1-interest-set-51-interest-set51-interest-set&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#5-1-interest-set&#34;  title=&#34;5.1 interest set&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;5.1 interest set&lt;/h2&gt;
&lt;p&gt;通过调用 &lt;code&gt;#interestOps()&lt;/code&gt; 方法，返回感兴趣的事件集合。示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int interestSet = selectionKey.interestOps();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 判断对哪些事件感兴趣  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;boolean isInterestedInAccept  = interestSet &amp;amp; SelectionKey.OP_ACCEPT != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;boolean isInterestedInConnect = interestSet &amp;amp; SelectionKey.OP_CONNECT != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;boolean isInterestedInRead    = interestSet &amp;amp; SelectionKey.OP_READ != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;boolean isInterestedInWrite   = interestSet &amp;amp; SelectionKey.OP_WRITE != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其中每个事件 Key 在 SelectionKey 中枚举，通过位( bit ) 表示。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;//  SelectionKey.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static final int OP_READ = 1 &amp;lt;&amp;lt; 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static final int OP_WRITE = 1 &amp;lt;&amp;lt; 2;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static final int OP_CONNECT = 1 &amp;lt;&amp;lt; 3;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static final int OP_ACCEPT = 1 &amp;lt;&amp;lt; 4;  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以，在上述示例的后半段的代码，可以通过与运算 &lt;code&gt;&amp;amp;&lt;/code&gt; 来判断是否对指定事件感兴趣。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-4-selector5-2-ready-set-52-ready-set52-ready-set&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#5-2-ready-set&#34;  title=&#34;5.2 ready set&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;5.2 ready set&lt;/h2&gt;
&lt;p&gt;通过调用 &lt;code&gt;#readyOps()&lt;/code&gt; 方法，返回就绪的事件集合。示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int readySet = selectionKey.readyOps();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 判断哪些事件已就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;selectionKey.isAcceptable();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;selectionKey.isConnectable();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;selectionKey.isReadable();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;selectionKey.isWritable();  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相比 interest set 来说，ready set 已经内置了判断事件的方法。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// SelectionKey.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final boolean isReadable() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return (readyOps() &amp;amp; OP_READ) != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final boolean isWritable() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return (readyOps() &amp;amp; OP_WRITE) != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final boolean isConnectable() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return (readyOps() &amp;amp; OP_CONNECT) != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public final boolean isAcceptable() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return (readyOps() &amp;amp; OP_ACCEPT) != 0;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-4-selector5-3-attachment-53-attachment53-attachment&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#5-3-attachment&#34;  title=&#34;5.3 attachment&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;5.3 attachment&lt;/h2&gt;
&lt;p&gt;通过调用 &lt;code&gt;#attach(Object ob)&lt;/code&gt; 方法，可以向 SelectionKey 添加附加对象；通过调用 &lt;code&gt;#attachment()&lt;/code&gt; 方法，可以获得 SelectionKey 获得附加对象。示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;selectionKey.attach(theObject);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Object attachedObj = selectionKey.attachment();  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;又获得在注册时，直接添加附加对象。示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector6-e9809ae8bf87-selector-e98089e68ba9-channel-6-通过-selector-选择-channel6-通过-selector-选择-channel&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#6-%E9%80%9A%E8%BF%87-Selector-%E9%80%89%E6%8B%A9-Channel&#34;  title=&#34;6. 通过 Selector 选择 Channel&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;6. 通过 Selector 选择 Channel&lt;/h1&gt;
&lt;p&gt;在 Selector 中，提供三种类型的选择( select )方法，返回当前有感兴趣事件准备就绪的 Channel &lt;strong&gt;数量&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// Selector.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 阻塞到至少有一个 Channel 在你注册的事件上就绪了。  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract int select() throws IOException;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 在 `#select()` 方法的基础上，增加超时机制。  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract int select(long timeout) throws IOException;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 和 `#select()` 方法不同，立即返回数量，而不阻塞。  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public abstract int selectNow() throws IOException;  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;有一点&lt;strong&gt;非常需要注意&lt;/strong&gt;：select 方法返回的 &lt;code&gt;int&lt;/code&gt; 值，表示有多少 Channel 已经就绪。亦即，&lt;strong&gt;自上次调用 select 方法后有多少 Channel 变成就绪状态&lt;/strong&gt;。如果调用 select 方法，因为有一个 Channel 变成就绪状态则返回了 1 ；若再次调用 select 方法，如果另一个 Channel 就绪了，它会再次返回1。如果对第一个就绪的 Channel 没有做任何操作，现在就有两个就绪的 Channel ，&lt;strong&gt;但在每次 select 方法调用之间，只有一个 Channel 就绪了，所以才返回 1&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector7-e88eb7e58f96e58fafe6938de4bd9ce79a84-channel-7-获取可操作的-channel7-获取可操作的-channel&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#7-%E8%8E%B7%E5%8F%96%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84-Channel&#34;  title=&#34;7. 获取可操作的 Channel&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;7. 获取可操作的 Channel&lt;/h1&gt;
&lt;p&gt;一旦调用了 select 方法，并且返回值表明有一个或更多个 Channel 就绪了，然后可以通过调用Selector 的 &lt;code&gt;#selectedKeys()&lt;/code&gt; 方法，访问“已选择键集( selected key set )”中的&lt;strong&gt;就绪&lt;/strong&gt; Channel 。示例代码所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Set selectedKeys = selector.selectedKeys();  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;注意，当有&lt;strong&gt;新增就绪&lt;/strong&gt;的 Channel ，需要先调用 select 方法，才会添加到“已选择键集( selected key set )”中。否则，我们直接调用 &lt;code&gt;#selectedKeys()&lt;/code&gt; 方法，是无法获得它们对应的 SelectionKey 们。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector8-e594a4e98692-selector-e98089e68ba9-8-唤醒-selector-选择8-唤醒-selector-选择&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#8-%E5%94%A4%E9%86%92-Selector-%E9%80%89%E6%8B%A9&#34;  title=&#34;8. 唤醒 Selector 选择&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;8. 唤醒 Selector 选择&lt;/h1&gt;
&lt;p&gt;某个线程调用 &lt;code&gt;#select()&lt;/code&gt; 方法后，发生阻塞了，即使没有通道已经就绪，也有办法让其从 &lt;code&gt;#select()&lt;/code&gt; 方法返回。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只要让其它线程在第一个线程调用 &lt;code&gt;select()&lt;/code&gt; 方法的那个 Selector 对象上，调用该 Selector 的 &lt;code&gt;#wakeup()&lt;/code&gt; 方法，进行唤醒该 Selector 即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么，阻塞在 &lt;code&gt;#select()&lt;/code&gt;方法上的线程，会立马返回。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Selector 的 &lt;code&gt;#select(long timeout)&lt;/code&gt; 方法，若未超时的情况下，也可以满足上述方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，如果有其它线程调用了 &lt;code&gt;#wakeup()&lt;/code&gt; 方法，但当前没有线程阻塞在 &lt;code&gt;#select()&lt;/code&gt; 方法上，下个调用 &lt;code&gt;#select()&lt;/code&gt; 方法的线程会立即被唤醒。😈 有点神奇。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector9-e585b3e997ad-selector-9-关闭-selector9-关闭-selector&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#9-%E5%85%B3%E9%97%AD-Selector&#34;  title=&#34;9. 关闭 Selector&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;9. 关闭 Selector&lt;/h1&gt;
&lt;p&gt;当我们不再使用 Selector 时，可以调用 Selector 的 &lt;code&gt;#close()&lt;/code&gt; 方法，将它进行关闭。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Selector 相关的所有 SelectionKey 都&lt;strong&gt;会失效&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Selector 相关的所有 Channel 并&lt;strong&gt;不会关闭&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，此时若有线程阻塞在 &lt;code&gt;#select()&lt;/code&gt; 方法上，也会被唤醒返回。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-4-selector10-e7ae80e58d95-selector-e7a4bae4be8b-10-简单-selector-示例10-简单-selector-示例&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#10-%E7%AE%80%E5%8D%95-Selector-%E7%A4%BA%E4%BE%8B&#34;  title=&#34;10. 简单 Selector 示例&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;10. 简单 Selector 示例&lt;/h1&gt;
&lt;p&gt;如下是一个简单的 Selector 示例，创建一个 Selector ，并将一个 Channel注册到这个 Selector上( Channel 的初始化过程略去 )，然后持续轮询这个 Selector 的四种事件( 接受，连接，读，写 )是否就绪。代码如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;老艿艿：本代码取自 &lt;a class=&#34;link&#34; href=&#34;http://ifeve.com/selectors/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Java NIO系列教程（六） Selector》&lt;/a&gt; 提供的示例，实际生产环境下并非这样的代码。🙂 最佳的实践，我们将在 Netty 中看到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 创建 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Selector selector = Selector.open();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 注册 Channel 到 Selector 中  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.configureBlocking(false);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SelectionKey key = channel.register(selector, SelectionKey.OP_READ);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;while (true) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 通过 Selector 选择 Channel   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int readyChannels = selector.select();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (readyChannels == 0) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; continue;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 获得可操作的 Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Set selectedKeys = selector.selectedKeys();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 遍历 SelectionKey 数组  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = selectedKeys.iterator();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; while (keyIterator.hasNext()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; SelectionKey key = keyIterator.next();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (key.isAcceptable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // a connection was accepted by a ServerSocketChannel.  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } else if (key.isConnectable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // a connection was established with a remote server.  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } else if (key.isReadable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // a channel is ready for reading  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } else if (key.isWritable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // a channel is ready for writing  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 移除  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; keyIterator.remove(); // &amp;lt;1&amp;gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 在每次迭代时, 我们都调用 &lt;code&gt;keyIterator.remove()&lt;/code&gt; 代码块，将这个 key 从迭代器中删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 &lt;code&gt;#select()&lt;/code&gt; 方法仅仅是简单地将就绪的 Channel 对应的 SelectionKey 放到 selected keys 集合中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此，如果我们从 selected keys 集合中，获取到一个 key ，但是没有将它删除，那么下一次 &lt;code&gt;#select&lt;/code&gt; 时, 这个 SelectionKey 还在 selectedKeys 中.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>netty源码分析五</title>
        <link>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94/</link>
        <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94/</guid>
        <description>&lt;p&gt;在前面的四篇文章，我们已经对 NIO 的概念已经有了一定的了解。当然，胖友也可能和我一样，已经被一堆概念烦死了。&lt;/p&gt;
&lt;p&gt;那么本文，我们撸起袖子，就是干代码，不瞎比比了。&lt;/p&gt;
&lt;p&gt;当然，下面更多的是提供一个 NIO 示例。真正生产级的 NIO 代码，建议胖友重新写，或者直接使用 Netty 。&lt;/p&gt;
&lt;p&gt;代码仓库在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/YunaiV/netty/tree/f7016330f1483021ef1c38e0923e1c8b7cef0d10/example/src/main/java/io/netty/example/yunai/nio&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;example/yunai/nio&lt;/a&gt; 目录下。一共 3 个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NioServer ：NIO 服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NioClient ：NIO 客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CodecUtil ：消息编解码工具类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-5-demo2-e69c8de58aa1e7abaf-2-服务端2-服务端&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF&#34;  title=&#34;2. 服务端&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2. 服务端&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 1: public class NioServer {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 2:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 3:     private ServerSocketChannel serverSocketChannel;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 4:     private Selector selector;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 5:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 6:     public NioServer() throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 7:         // 打开 Server Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 8:         serverSocketChannel = ServerSocketChannel.open();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 9:         // 配置为非阻塞  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 10:         serverSocketChannel.configureBlocking(false);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 11:         // 绑定 Server port  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 12:         serverSocketChannel.socket().bind(new InetSocketAddress(8080));  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 13:         // 创建 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 14:         selector = Selector.open();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 15:         // 注册 Server Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 16:         serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 17:         System.out.println(&amp;#34;Server 启动完成&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 18:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 19:         handleKeys();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 20:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 21:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 22:     private void handleKeys() throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 23:         while (true) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 24:             // 通过 Selector 选择 Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 25:             int selectNums = selector.select(30 \* 1000L);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 26:             if (selectNums == 0) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 27:                 continue;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 28:             }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 29:             System.out.println(&amp;#34;选择 Channel 数量：&amp;#34; \+ selectNums);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 30:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 31:             // 遍历可选择的 Channel 的 SelectionKey 集合  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 32:             Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 33:             while (iterator.hasNext()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 34:                 SelectionKey key = iterator.next();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 35:                 iterator.remove(); // 移除下面要处理的 SelectionKey  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 36:                 if (!key.isValid()) { // 忽略无效的 SelectionKey  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 37:                     continue;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 38:                 }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 39:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 40:                 handleKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 41:             }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 42:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 43:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 44:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 45:     private void handleKey(SelectionKey key) throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 46:         // 接受连接就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 47:         if (key.isAcceptable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 48:             handleAcceptableKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 49:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 50:         // 读就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 51:         if (key.isReadable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 52:             handleReadableKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 53:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 54:         // 写就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 55:         if (key.isWritable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 56:             handleWritableKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 57:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 58:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 59:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 60:     private void handleAcceptableKey(SelectionKey key) throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 61:         // 接受 Client Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 62:         SocketChannel clientSocketChannel = ((ServerSocketChannel) key.channel()).accept();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 63:         // 配置为非阻塞  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 64:         clientSocketChannel.configureBlocking(false);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 65:         // log  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 66:         System.out.println(&amp;#34;接受新的 Channel&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 67:         // 注册 Client Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 68:         clientSocketChannel.register(selector, SelectionKey.OP_READ, new ArrayList&amp;lt;String&amp;gt;());  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 69:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 70:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 71:     private void handleReadableKey(SelectionKey key) throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 72:         // Client Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 73:         SocketChannel clientSocketChannel = (SocketChannel) key.channel();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 74:         // 读取数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 75:         ByteBuffer readBuffer = CodecUtil.read(clientSocketChannel);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 76:         // 处理连接已经断开的情况  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 77:         if (readBuffer == null) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 78:             System.out.println(&amp;#34;断开 Channel&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 79:             clientSocketChannel.register(selector, 0);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 80:             return;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 81:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 82:         // 打印数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 83:         if (readBuffer.position() &amp;gt; 0) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 84:             String content = CodecUtil.newString(readBuffer);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 85:             System.out.println(&amp;#34;读取数据：&amp;#34; \+ content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 86:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 87:             // 添加到响应队列  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 88:             List&amp;lt;String&amp;gt; responseQueue = (ArrayList&amp;lt;String&amp;gt;) key.attachment();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 89:             responseQueue.add(&amp;#34;响应：&amp;#34; \+ content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 90:             // 注册 Client Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 91:             clientSocketChannel.register(selector, SelectionKey.OP_WRITE, key.attachment());  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 92:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 93:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 94:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 95:     @SuppressWarnings(&amp;#34;Duplicates&amp;#34;)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 96:     private void handleWritableKey(SelectionKey key) throws ClosedChannelException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 97:         // Client Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 98:         SocketChannel clientSocketChannel = (SocketChannel) key.channel();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 99:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;100:         // 遍历响应队列  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;101:         List&amp;lt;String&amp;gt; responseQueue = (ArrayList&amp;lt;String&amp;gt;) key.attachment();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;102:         for (String content : responseQueue) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;103:             // 打印数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;104:             System.out.println(&amp;#34;写入数据：&amp;#34; \+ content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;105:             // 返回  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;106:             CodecUtil.write(clientSocketChannel, content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;107:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;108:         responseQueue.clear();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;109:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;110:         // 注册 Client Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;111:         clientSocketChannel.register(selector, SelectionKey.OP_READ, responseQueue);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;112:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;113:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;114:     public static void main(String\[\] args) throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;115:         NioServer server = new NioServer();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;116:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;117:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;118: }  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;整块代码我们可以分成 3 部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构造方法：初始化 NIO 服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#handleKeys()&lt;/code&gt; 方法：基于 Selector 处理 IO 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#main(String[] args)&lt;/code&gt; 方法：创建 NIO 服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面，我们逐小节来分享。&lt;/p&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo2-1-e69e84e980a0e696b9e6b395-21-构造方法21-构造方法&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&#34;  title=&#34;2.1 构造方法&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.1 构造方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 3 至 20 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;serverSocketChannel&lt;/code&gt; 属性，服务端的 ServerSocketChannel ，在【第 7 至 12 行】的代码进行初始化，重点是此处启动了服务端，并监听指定端口( 此处为 8080 )。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;selector&lt;/code&gt; 属性，选择器，在【第 14 至 16 行】的代码进行初始化，重点是此处将 &lt;code&gt;serverSocketChannel&lt;/code&gt; 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_ACCEPT&lt;/code&gt; 事件感兴趣。这样子，在客户端连接服务端时，我们就可以处理该 IO 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 19 行：调用 &lt;code&gt;#handleKeys()&lt;/code&gt; 方法，基于 Selector 处理 IO 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo2-2-handlekeys-22-handlekeys22-handlekeys&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-2-handleKeys&#34;  title=&#34;2.2 handleKeys&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.2 handleKeys&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 22 至 43 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 23 行：死循环。本文的示例，不考虑服务端关闭的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 24 至 29 行：调用 &lt;code&gt;Selector#select(long timeout)&lt;/code&gt; 方法，每 30 秒阻塞等待有就绪的 IO 事件。此处的 30 秒为笔者随意写的，实际也可以改成其他超时时间，或者 &lt;code&gt;Selector#select()&lt;/code&gt; 方法。当不存在就绪的 IO 事件，直接 &lt;code&gt;continue&lt;/code&gt; ，继续下一次阻塞等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 32 行：调用 &lt;code&gt;Selector#selectedKeys()&lt;/code&gt; 方法，获得有就绪的 IO 事件( 也可以称为“选择的” ) Channel 对应的 SelectionKey 集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 33 行 至 35 行：遍历 &lt;code&gt;iterator&lt;/code&gt; ，进行逐个 SelectionKey 处理。重点注意下，处理完需要进行移除，具体原因，在 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-4-selector/#10-%E7%AE%80%E5%8D%95-Selector-%E7%A4%BA%E4%BE%8B&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Netty 源码分析 —— NIO 基础（四）之 Selector》「10. 简单 Selector 示例」&lt;/a&gt; 有详细解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 36 至 38 行：在遍历的过程中，可能该 SelectionKey 已经&lt;strong&gt;失效&lt;/strong&gt;，直接 &lt;code&gt;continue&lt;/code&gt; ，不进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 40 行：调用 &lt;code&gt;#handleKey()&lt;/code&gt; 方法，逐个 SelectionKey 处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo2-2-1-handlekey-221-handlekey221-handlekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-2-1-handleKey&#34;  title=&#34;2.2.1 handleKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.2.1 handleKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 45 至 58 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过调用 SelectionKey 的 &lt;code&gt;#isAcceptable()&lt;/code&gt;、&lt;code&gt;#isReadable()&lt;/code&gt;、&lt;code&gt;#isWritable()&lt;/code&gt; 方法，&lt;strong&gt;分别&lt;/strong&gt;判断 Channel 是&lt;strong&gt;接受连接&lt;/strong&gt;就绪，还是&lt;strong&gt;读&lt;/strong&gt;就绪，或是&lt;strong&gt;写&lt;/strong&gt;就绪，并调用相应的 &lt;code&gt;#handleXXXX(SelectionKey key)&lt;/code&gt; 方法，处理对应的 IO 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 SelectionKey 可以&lt;strong&gt;同时&lt;/strong&gt;对&lt;strong&gt;一个&lt;/strong&gt; Channel 的&lt;strong&gt;多个&lt;/strong&gt;事件感兴趣，所以此处的代码都是 &lt;code&gt;if&lt;/code&gt; 判断，而不是 &lt;code&gt;if else&lt;/code&gt; 判断。😈 虽然，考虑到让示例更简单，本文的并未编写同时对一个 Channel 的多个事件感兴趣，后续我们会在 Netty 的源码解析中看到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SelectionKey.OP_CONNECT&lt;/code&gt; 使用在&lt;strong&gt;客户端&lt;/strong&gt;中，所以此处不需要做相应的判断和处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo2-2-2-handleacceptablekey-222-handleacceptablekey222-handleacceptablekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-2-2-handleAcceptableKey&#34;  title=&#34;2.2.2 handleAcceptableKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.2.2 handleAcceptableKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 60 至 69 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 62 行：调用 &lt;code&gt;ServerSocketChannel#accept()&lt;/code&gt; 方法，获得连接的客户端的 SocketChannel 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 64 行：配置客户端的 SocketChannel 为非阻塞，否则无法使用 Selector 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 66 行：打印日志，方便调试。实际场景下，使用 Logger 而不要使用 &lt;code&gt;System.out&lt;/code&gt; 进行输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 68 行：注册客户端的 SocketChannel 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; 事件感兴趣。这样子，在客户端发送消息( 数据 )到服务端时，我们就可以处理该 IO 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么不对 &lt;code&gt;SelectionKey.OP_WRITE&lt;/code&gt; 事件感兴趣呢？因为这个时候，服务端一般不会主动向客户端发送消息，所以不需要对 &lt;code&gt;SelectionKey.OP_WRITE&lt;/code&gt; 事件感兴趣。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;细心的胖友会发现，&lt;code&gt;Channel#register(Selector selector, int ops, Object attachment)&lt;/code&gt; 方法的第 3 个参数，我们注册了 SelectionKey 的 &lt;code&gt;attachment&lt;/code&gt; 属性为 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; ，这又是为什么呢？结合下面的 &lt;code&gt;#handleReadableKey(Selection key)&lt;/code&gt; 方法，我们一起解析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo2-2-3-handlereadablekey-223-handlereadablekey223-handlereadablekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-2-3-handleReadableKey&#34;  title=&#34;2.2.3 handleReadableKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.2.3 handleReadableKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 71 至 93 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 73 行：调用 &lt;code&gt;SelectionKey#channel()&lt;/code&gt; 方法，获得该 SelectionKey 对应的 SocketChannel ，即客户端的 SocketChannel 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 75 行：调用 &lt;code&gt;CodecUtil#read(SocketChannel channel)&lt;/code&gt; 方法，读取数据。具体代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// CodecUtil.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static ByteBuffer read(SocketChannel channel) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 注意，不考虑拆包的处理  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ByteBuffer buffer = ByteBuffer.allocate(1024);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; try {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; int count = channel.read(buffer);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; if (count == -1) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return null;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } catch (IOException e) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new RuntimeException(e);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return buffer;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑到示例的简单性，数据的读取，就不考虑拆包的处理。不理解的胖友，可以自己 Google 下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;SocketChannel#read(ByteBuffer)&lt;/code&gt; 方法，读取 Channel 的缓冲区的数据到 ByteBuffer 中。若返回的结果( &lt;code&gt;count&lt;/code&gt; ) 为 -1 ，意味着客户端连接已经断开，我们直接返回 &lt;code&gt;null&lt;/code&gt; 。为什么是返回 &lt;code&gt;null&lt;/code&gt; 呢？下面继续见分晓。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 76 至 81 行：若读取数据返回的结果为 &lt;code&gt;null&lt;/code&gt; 时，意味着客户端的连接已经断开，因此取消注册 &lt;code&gt;selector&lt;/code&gt; 对该客户端的 SocketChannel 的感兴趣的 IO 事件。通过调用注册方法，并且第 2 个参数 &lt;code&gt;ops&lt;/code&gt; 为 0 ，可以达到取消注册的效果。😈 感兴趣的胖友，可以将这行代码进行注释，测试下效果就很容易明白了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 83 行：通过调用 &lt;code&gt;ByteBuffer#position()&lt;/code&gt; 大于 0 ，来判断&lt;strong&gt;实际&lt;/strong&gt;读取到数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以，此处笔者在示例中，处理的方式为添加响应数据到 &lt;code&gt;responseQueue&lt;/code&gt; 中，并在【第 91 行】的代码中，注册客户端的 SocketChannel 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_WRITE&lt;/code&gt; 事件感兴趣。这样子，在 SocketChannel &lt;strong&gt;写就绪&lt;/strong&gt;时，在 &lt;code&gt;#handleWritableKey(SelectionKey key)&lt;/code&gt; 方法中，统一处理写数据给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当然，还是因为是示例，所以这样的实现方式不是最优。在 Netty 中，具体的实现方式是，先尝试调用 &lt;code&gt;SocketChannel#write(ByteBuf)&lt;/code&gt; 方法，写数据给客户端。若写入失败( 方法返回结果为 0 )时，再进行类似笔者的上述实现方式。牛逼！Netty ！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不太理解分享的原因，可以再阅读如下两篇文章：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/V4tEH1j64FHFmB8bReNI7g&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《深夜对话：NIO 中 SelectionKey.OP_WRITE 你了解多少》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/a34140974/article/details/48464845&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Java.nio 中 socketChannle.write() 返回 0 的简易解决方案》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;😈 如果不理解，木有关系，在 &lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Dubbo/remoting-api-transport/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《精尽 Dubbo 源码分析 —— NIO 服务器（二）之 Transport 层》「8. Dispacher」&lt;/a&gt; 中，有详细解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🙂 考虑到示例的简洁性，所以在【第 88 至 89 行】的代码中，我们直接返回（&lt;code&gt;&amp;quot;响应：&amp;quot;&lt;/code&gt; + 请求内容）给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意，需要调用 &lt;code&gt;ByteBuffer#flip()&lt;/code&gt; 方法，将 ByteBuffer 从&lt;strong&gt;写&lt;/strong&gt;模式切换到&lt;strong&gt;读&lt;/strong&gt;模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 84 至 85 行：调用 &lt;code&gt;CodecUtil#newString(ByteBuffer)&lt;/code&gt; 方法，格式化为字符串，并进行打印。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// CodecUtil.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static String newString(ByteBuffer buffer) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; buffer.flip();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; byte\[\] bytes = new byte\[buffer.remaining()\];  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; System.arraycopy(buffer.array(), buffer.position(), bytes, 0, buffer.remaining());  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; try {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; return new String(bytes, &amp;#34;UTF-8&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } catch (UnsupportedEncodingException e) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new RuntimeException(e);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 86 行：一般在此处，我们可以进行一些业务逻辑的处理，并返回处理的相应结果。例如，我们熟悉的 Request / Response 的处理。当然，考虑到性能，我们甚至可以将逻辑的处理，丢到逻辑线程池。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 88 行：通过调用 &lt;code&gt;SelectionKey#attachment()&lt;/code&gt; 方法，获得我们&lt;strong&gt;附加&lt;/strong&gt;在 SelectionKey 的响应队列( &lt;code&gt;responseQueue&lt;/code&gt; )。可能有胖友会问啦，为什么不调用 &lt;code&gt;SocketChannel#write(ByteBuf)&lt;/code&gt; 方法，直接写数据给客户端呢？虽然大多数情况下，SocketChannel 都是&lt;strong&gt;可写&lt;/strong&gt;的，但是如果写入比较频繁，超过 SocketChannel 的缓存区大小，就会导致数据“&lt;strong&gt;丢失&lt;/strong&gt;”，并未写给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 91 行：有一点需要注意，&lt;code&gt;Channel#register(Selector selector, int ops, Object attachment)&lt;/code&gt; 方法的第 3 个参数，需要继续传入响应队列( &lt;code&gt;responseQueue&lt;/code&gt; )，因为每次注册生成&lt;strong&gt;新&lt;/strong&gt;的 SelectionKey 。若不传入，下面的 &lt;code&gt;#handleWritableKey(SelectionKey key)&lt;/code&gt; 方法，会获得不到响应队列( &lt;code&gt;responseQueue&lt;/code&gt; )。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo2-2-4-handlewritablekey-224-handlewritablekey224-handlewritablekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-2-4-handleWritableKey&#34;  title=&#34;2.2.4 handleWritableKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.2.4 handleWritableKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 96 至 112 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 98 行：调用 &lt;code&gt;SelectionKey#channel()&lt;/code&gt; 方法，获得该 SelectionKey 对应的 SocketChannel ，即客户端的 SocketChannel 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 101 行：通过调用 &lt;code&gt;SelectionKey#attachment()&lt;/code&gt; 方法，获得我们&lt;strong&gt;附加&lt;/strong&gt;在 SelectionKey 的响应队列( &lt;code&gt;responseQueue&lt;/code&gt; )。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码比较简单，&lt;strong&gt;还是要注意&lt;/strong&gt;，需要调用 &lt;code&gt;ByteBuffer#flip()&lt;/code&gt; 方法，将 ByteBuffer 从&lt;strong&gt;写&lt;/strong&gt;模式切换到&lt;strong&gt;读&lt;/strong&gt;模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 102 行：遍历响应队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 106 行：调用 &lt;code&gt;CodeUtil#write(SocketChannel, content)&lt;/code&gt; 方法，写入响应数据给客户端。代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // CodecUtil.java  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static void write(SocketChannel channel, String content) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 写入 Buffer  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ByteBuffer buffer = ByteBuffer.allocate(1024);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; try {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; buffer.put(content.getBytes(&amp;#34;UTF-8&amp;#34;));  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } catch (UnsupportedEncodingException e) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new RuntimeException(e);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 写入 Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; buffer.flip();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; try {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; // 注意，不考虑写入超过 Channel 缓存区上限。  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; channel.write(buffer);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; } catch (IOException e) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; throw new RuntimeException(e);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 111 行：&lt;strong&gt;注意&lt;/strong&gt;，再结束写入后，需要&lt;strong&gt;重新&lt;/strong&gt;注册客户端的 SocketChannel 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; 事件感兴趣。为什么呢？其实还是我们在上文中提到的，大多数情况下，SocketChannel &lt;strong&gt;都是写就绪的&lt;/strong&gt;，如果不取消掉注册掉对 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; 事件感兴趣，就会导致反复触发无用的写事件处理。😈 感兴趣的胖友，可以将这行代码进行注释，测试下效果就很容易明白了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo2-3-main-23-main23-main&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#2-3-main&#34;  title=&#34;2.3 main&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2.3 main&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 114 至 116 行】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;比较简单，就是创建一个 NioServer 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;撸到此处，我们可以直接通过 &lt;code&gt;telnet 127.0.0.1 8080&lt;/code&gt; 的方式，连接服务端，进行读写数据的测试。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-5-demo3-e5aea2e688b7e7abaf-3-客户端3-客户端&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-%E5%AE%A2%E6%88%B7%E7%AB%AF&#34;  title=&#34;3. 客户端&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3. 客户端&lt;/h1&gt;
&lt;p&gt;客户端的实现代码，绝大数和服务端相同，所以我们分析的相对会简略一些。不然，自己都嫌弃自己太啰嗦了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;119
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;120
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;121
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;122
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;123
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;124
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;125
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;126
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;127
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;128
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;129
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;130
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;131
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;132
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;133
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;134
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;135
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;136
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;137
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;138
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;139
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;140
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 1: public class NioClient {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 2:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 3:     private SocketChannel clientSocketChannel;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 4:     private Selector selector;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 5:     private final List&amp;lt;String&amp;gt; responseQueue = new ArrayList&amp;lt;String&amp;gt;();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 6:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 7:     private CountDownLatch connected = new CountDownLatch(1);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 8:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 9:     public NioClient() throws IOException, InterruptedException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 10:         // 打开 Client Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 11:         clientSocketChannel = SocketChannel.open();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 12:         // 配置为非阻塞  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 13:         clientSocketChannel.configureBlocking(false);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 14:         // 创建 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 15:         selector = Selector.open();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 16:         // 注册 Server Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 17:         clientSocketChannel.register(selector, SelectionKey.OP_CONNECT);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 18:         // 连接服务器  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 19:         clientSocketChannel.connect(new InetSocketAddress(8080));  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 20:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 21:         new Thread(new Runnable() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 22:             @Override  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 23:             public void run() {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 24:                 try {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 25:                     handleKeys();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 26:                 } catch (IOException e) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 27:                     e.printStackTrace();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 28:                 }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 29:             }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 30:         }).start();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 31:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 32:         if (connected.getCount() != 0) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 33:             connected.await();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 34:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 35:         System.out.println(&amp;#34;Client 启动完成&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 36:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 37:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 38:     @SuppressWarnings(&amp;#34;Duplicates&amp;#34;)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 39:     private void handleKeys() throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 40:         while (true) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 41:             // 通过 Selector 选择 Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 42:             int selectNums = selector.select(30 \* 1000L);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 43:             if (selectNums == 0) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 44:                 continue;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 45:             }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 46:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 47:             // 遍历可选择的 Channel 的 SelectionKey 集合  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 48:             Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 49:             while (iterator.hasNext()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 50:                 SelectionKey key = iterator.next();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 51:                 iterator.remove(); // 移除下面要处理的 SelectionKey  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 52:                 if (!key.isValid()) { // 忽略无效的 SelectionKey  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 53:                     continue;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 54:                 }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 55:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 56:                 handleKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 57:             }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 58:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 59:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 60:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 61:     private synchronized void handleKey(SelectionKey key) throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 62:         // 接受连接就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 63:         if (key.isConnectable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 64:             handleConnectableKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 65:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 66:         // 读就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 67:         if (key.isReadable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 68:             handleReadableKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 69:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 70:         // 写就绪  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 71:         if (key.isWritable()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 72:             handleWritableKey(key);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 73:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 74:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 75:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 76:     private void handleConnectableKey(SelectionKey key) throws IOException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 77:         // 完成连接  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 78:         if (!clientSocketChannel.isConnectionPending()) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 79:             return;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 80:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 81:         clientSocketChannel.finishConnect();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 82:         // log  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 83:         System.out.println(&amp;#34;接受新的 Channel&amp;#34;);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 84:         // 注册 Client Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 85:         clientSocketChannel.register(selector, SelectionKey.OP_READ, responseQueue);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 86:         // 标记为已连接  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 87:         connected.countDown();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 88:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 89:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 90:     @SuppressWarnings(&amp;#34;Duplicates&amp;#34;)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 91:     private void handleReadableKey(SelectionKey key) throws ClosedChannelException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 92:         // Client Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 93:         SocketChannel clientSocketChannel = (SocketChannel) key.channel();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 94:         // 读取数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 95:         ByteBuffer readBuffer = CodecUtil.read(clientSocketChannel);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 96:         // 打印数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 97:         if (readBuffer.position() &amp;gt; 0) { // 写入模式下，  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 98:             String content = CodecUtil.newString(readBuffer);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 99:             System.out.println(&amp;#34;读取数据：&amp;#34; \+ content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;100:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;101:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;102:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;103:     @SuppressWarnings(&amp;#34;Duplicates&amp;#34;)  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;104:     private void handleWritableKey(SelectionKey key) throws ClosedChannelException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;105:         // Client Socket Channel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;106:         SocketChannel clientSocketChannel = (SocketChannel) key.channel();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;107:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;108:         // 遍历响应队列  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;109:         List&amp;lt;String&amp;gt; responseQueue = (ArrayList&amp;lt;String&amp;gt;) key.attachment();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;110:         for (String content : responseQueue) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;111:             // 打印数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;112:             System.out.println(&amp;#34;写入数据：&amp;#34; \+ content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;113:             // 返回  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;114:             CodecUtil.write(clientSocketChannel, content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;115:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;116:         responseQueue.clear();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;117:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;118:         // 注册 Client Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;119:         clientSocketChannel.register(selector, SelectionKey.OP_READ, responseQueue);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;120:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;121:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;122:     public synchronized void send(String content) throws ClosedChannelException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;123:         // 添加到响应队列  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;124:         responseQueue.add(content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;125:         // 打印数据  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;126:         System.out.println(&amp;#34;写入数据：&amp;#34; \+ content);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;127:         // 注册 Client Socket Channel 到 Selector  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;128:         clientSocketChannel.register(selector, SelectionKey.OP_WRITE, responseQueue);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;129:         selector.wakeup();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;130:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;131:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;132:     public static void main(String\[\] args) throws IOException, InterruptedException {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;133:         NioClient client = new NioClient();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;134:         for (int i = 0; i &amp;lt; 30; i++) {  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;135:             client.send(&amp;#34;nihao: &amp;#34; \+ i);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;136:             Thread.sleep(1000L);  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;137:         }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;138:     }  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;139:   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;140: }  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;整块代码我们可以分成 3 部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构造方法：初始化 NIO 客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#handleKeys()&lt;/code&gt; 方法：基于 Selector 处理 IO 操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#main(String[] args)&lt;/code&gt; 方法：创建 NIO 客户端，并向服务器发送请求数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面，我们逐小节来分享。&lt;/p&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo3-1-e69e84e980a0e696b9e6b395-31-构造方法31-构造方法&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&#34;  title=&#34;3.1 构造方法&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.1 构造方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 3 至 36 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;clientSocketChannel&lt;/code&gt; 属性，客户端的 SocketChannel ，在【第 9 至 13 行】和【第 19 行】的代码进行初始化，重点是此处连接了指定服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;selector&lt;/code&gt; 属性，选择器，在【第 14 至 17 行】的代码进行初始化，重点是此处将 &lt;code&gt;clientSocketChannel&lt;/code&gt; 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_CONNECT&lt;/code&gt; 事件感兴趣。这样子，在客户端连接服务端&lt;strong&gt;成功&lt;/strong&gt;时，我们就可以处理该 IO 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;responseQueue&lt;/code&gt; 属性，直接声明为 NioClient 的成员变量，是为了方便 &lt;code&gt;#send(String content)&lt;/code&gt; 方法的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 21 至 30 行：调用 &lt;code&gt;#handleKeys()&lt;/code&gt; 方法，基于 Selector 处理 IO 事件。比较特殊的是，我们是启动了一个&lt;strong&gt;线程&lt;/strong&gt;进行处理。因为在后续的 &lt;code&gt;#main()&lt;/code&gt; 方法中，我们需要调用发送请求数据的方法，不能直接在&lt;strong&gt;主线程&lt;/strong&gt;，轮询处理 IO 事件。😈 机智的胖友，可能已经发现，NioServer 严格来说，也是应该这样处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 32 至 34 行：通过 CountDownLatch 来实现阻塞等待客户端成功连接上服务端。具体的 &lt;code&gt;CountDownLatch#countDown()&lt;/code&gt; 方法，在 &lt;code&gt;#handleConnectableKey(SelectionKey key)&lt;/code&gt; 方法中调用。当然，除了可以使用 CountDownLatch 来实现阻塞等待，还可以通过如下方式:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Object 的 wait 和 notify 的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lock 的 await 和 notify 的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Queue 的阻塞等待方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;😈 开心就好，皮一下很开心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo3-2-handlekeys-32-handlekeys32-handlekeys&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-2-handleKeys&#34;  title=&#34;3.2 handleKeys&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.2 handleKeys&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 38 至 59 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;完全&lt;/strong&gt;和 NioServer 中的该方法一模一样，省略。&lt;/p&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo3-2-1-handlekey-321-handlekey321-handlekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-2-1-handleKey&#34;  title=&#34;3.2.1 handleKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.2.1 handleKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 61 至 74 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;大体&lt;/strong&gt;逻辑和 NioServer 中的该方法一模一样，差别将对 &lt;code&gt;SelectionKey.OP_WRITE&lt;/code&gt; 事件的处理改成对 &lt;code&gt;SelectionKey.OP_CONNECT&lt;/code&gt; 事件的处理。&lt;/p&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo3-3-2-handleconnectablekey-332-handleconnectablekey332-handleconnectablekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-3-2-handleConnectableKey&#34;  title=&#34;3.3.2 handleConnectableKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.3.2 handleConnectableKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 76 至 88 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 77 至 81 行：判断客户端的 SocketChannel 上是否&lt;strong&gt;正在进行连接&lt;/strong&gt;的操作，若是，则完成连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 83 行：打印日志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 85 行：注册客户端的 SocketChannel 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_READ&lt;/code&gt; 事件感兴趣。这样子，在客户端接收到到服务端的消息( 数据 )时，我们就可以处理该 IO 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 87 行：调用 &lt;code&gt;CountDownLatch#countDown()&lt;/code&gt; 方法，结束 NioClient 构造方法中的【第 32 至 34 行】的阻塞等待连接完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo3-3-3-handlereadablekey-333-handlereadablekey333-handlereadablekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-3-3-handleReadableKey&#34;  title=&#34;3.3.3 handleReadableKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.3.3 handleReadableKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 91 至 101 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;大体&lt;/strong&gt;逻辑和 NioServer 中的该方法一模一样，&lt;strong&gt;去掉响应请求的相关逻辑&lt;/strong&gt;。😈 如果不去掉，就是客户端和服务端互发消息的“死循环”了。&lt;/p&gt;
&lt;h3 id=&#34;httpsvipiocodercnnettynio-5-demo3-3-4-handlewritablekey-334-handlewritablekey334-handlewritablekey&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-3-4-handleWritableKey&#34;  title=&#34;3.3.4 handleWritableKey&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.3.4 handleWritableKey&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 103 至 120 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;完全&lt;/strong&gt;和 NioServer 中的该方法一模一样。&lt;/p&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo3-3-send-33-send33-send&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-3-send&#34;  title=&#34;3.3 send&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.3 send&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 122 至 130 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;客户端发送请求消息给服务端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 124 行：添加到响应队列( &lt;code&gt;responseQueue&lt;/code&gt; ) 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 126 行：打印日志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 128 行：注册客户端的 SocketChannel 到 &lt;code&gt;selector&lt;/code&gt; 中，并对 &lt;code&gt;SelectionKey.OP_WRITE&lt;/code&gt; 事件感兴趣。具体的原因，和 NioServer 的 &lt;code&gt;#handleReadableKey(SelectionKey key)&lt;/code&gt; 方法的【第 88 行】一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 129 行：调用 &lt;code&gt;Selector#wakeup()&lt;/code&gt; 方法，唤醒 &lt;code&gt;#handleKeys()&lt;/code&gt; 方法中，&lt;code&gt;Selector#select(long timeout)&lt;/code&gt; 方法的阻塞等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为，在 &lt;code&gt;Selector#select(long timeout)&lt;/code&gt; 方法的实现中，是以调用&lt;strong&gt;当时&lt;/strong&gt;，对 SocketChannel 的感兴趣的事件 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以，在【第 128 行】的代码中，即使修改了对 SocketChannel 的感兴趣的事件，也不会结束 &lt;code&gt;Selector#select(long timeout)&lt;/code&gt; 方法的阻塞等待。因此，需要进行唤醒操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;😈 感兴趣的胖友，可以将这行代码进行注释，测试下效果就很容易明白了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-5-demo3-4-main-34-main34-main&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-5-demo/#3-4-main&#34;  title=&#34;3.4 main&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.4 main&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对应【第 132 至 137 行】的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 133 行：创建一个 NioClient 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 134 至 137 行：每秒发送一次请求。考虑到代码没有处理拆包的逻辑，所以增加了间隔 1 秒的 sleep 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>netty源码分析一</title>
        <link>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/</link>
        <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://tauzi.github.io/myblog/p/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/</guid>
        <description>&lt;h1 id=&#34;精尽-netty-源码分析--nio-基础一之简介&#34;&gt;精尽 Netty 源码分析 —— NIO 基础（一）之简介&lt;/h1&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-1-intro1-e6a682e8bfb0-1-概述1-概述&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#1-%E6%A6%82%E8%BF%B0&#34;  title=&#34;1. 概述&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;Java NIO( New IO 或者 Non Blocking IO ) ，从 Java 1.4 版本开始引入的&lt;strong&gt;非阻塞&lt;/strong&gt; IO ，用于替换&lt;strong&gt;标准&lt;/strong&gt;( 有些文章也称为&lt;strong&gt;传统&lt;/strong&gt;，或者 Blocking IO 。下文统称为 BIO ) Java IO API 的 IO API 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;老艿艿：在一些文章中，会将 Java NIO 描述成&lt;strong&gt;异步&lt;/strong&gt; IO ，实际是不太正确的： Java NIO 是&lt;strong&gt;同步&lt;/strong&gt; IO ，Java AIO ( 也称为 NIO 2 )是&lt;strong&gt;异步&lt;/strong&gt; IO。具体原因，推荐阅读文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/matthew_zhang/article/details/71328697&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《异步和非阻塞一样吗? (内容涉及 BIO, NIO, AIO, Netty)》&lt;/a&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/skiof007/article/details/52873421&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《BIO与NIO、AIO的区别(这个容易理解)》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来说，在 &lt;strong&gt;Unix IO 模型&lt;/strong&gt;的语境下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步和异步的区别：数据拷贝阶段是否需要完全由操作系统处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞和非阻塞操作：是针对发起 IO 请求操作后，是否有立刻返回一个标志信息而不让请求线程等待。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，Java NIO 是&lt;strong&gt;同步&lt;/strong&gt;且非阻塞的 IO 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-1-intro2-e6a0b8e5bf83e7bb84e4bbb6-2-核心组件2-核心组件&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6&#34;  title=&#34;2. 核心组件&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;2. 核心组件&lt;/h1&gt;
&lt;p&gt;Java NIO 由如下&lt;strong&gt;三个&lt;/strong&gt;核心组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Channel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buffer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Selector&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后续的每篇文章，我们会分享对应的一个组件。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-1-intro3-nio-e5928c-bio-e79a84e5afb9e6af94-3-nio-和-bio-的对比3-nio-和-bio-的对比&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#3-NIO-%E5%92%8C-BIO-%E7%9A%84%E5%AF%B9%E6%AF%94&#34;  title=&#34;3. NIO 和 BIO 的对比&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3. NIO 和 BIO 的对比&lt;/h1&gt;
&lt;p&gt;NIO 和 BIO 的区别主要体现在三个方面：&lt;/p&gt;
&lt;p&gt;NIO&lt;/p&gt;
&lt;p&gt;BIO&lt;/p&gt;
&lt;p&gt;基于缓冲区( Buffer )&lt;/p&gt;
&lt;p&gt;基于流( Stream )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非&lt;/strong&gt;阻塞 IO&lt;/p&gt;
&lt;p&gt;阻塞 IO&lt;/p&gt;
&lt;p&gt;选择器( Selector )&lt;/p&gt;
&lt;p&gt;无&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中，选择器( Selector )是 NIO 能实现&lt;strong&gt;非&lt;/strong&gt;阻塞的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-1-intro3-1-e59fbae4ba8e-buffer-e4b88ee59fbae4ba8e-stream-31-基于-buffer-与基于-stream31-基于-buffer-与基于-stream&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#3-1-%E5%9F%BA%E4%BA%8E-Buffer-%E4%B8%8E%E5%9F%BA%E4%BA%8E-Stream&#34;  title=&#34;3.1 基于 Buffer 与基于 Stream&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.1 基于 Buffer 与基于 Stream&lt;/h2&gt;
&lt;p&gt;BIO 是面向字节流或者字符流的，而在 NIO 中，它摒弃了传统的 IO 流，而是引入 Channel 和 Buffer 的概念：从 Channel 中读取数据到 Buffer 中，或者将数据从 Buffer 中写到 Channel 中。&lt;/p&gt;
&lt;p&gt;① 那么什么是&lt;strong&gt;基于 Stream&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;在一般的 Java IO 操作中，我们以&lt;strong&gt;流式&lt;/strong&gt;的方式，&lt;strong&gt;顺序&lt;/strong&gt;的从一个 Stream 中读取一个或者多个字节，直至读取所有字节。因为它没有缓存区，所以我们就不能随意改变读取指针的位置。&lt;/p&gt;
&lt;p&gt;② 那么什么是&lt;strong&gt;基于 Buffer&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;p&gt;基于 Buffer 就显得有点不同了。我们在从 Channel 中读取数据到 Buffer 中，这样 Buffer 中就有了数据后，我们就可以对这些数据进行操作了。并且不同于一般的 Java IO 操作那样是&lt;strong&gt;顺序&lt;/strong&gt;操作，NIO 中我们可以随意的读取任意位置的数据，这样大大增加了处理过程中的灵活性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;老艿艿：&lt;strong&gt;写入&lt;/strong&gt;操作，也符合上述&lt;strong&gt;读取&lt;/strong&gt;操作的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-1-intro3-2-e998bbe5a19ee4b88ee99d9ee998bbe5a19e-io-32-阻塞与非阻塞-io32-阻塞与非阻塞-io&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#3-2-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E-IO&#34;  title=&#34;3.2 阻塞与非阻塞 IO&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.2 阻塞与非阻塞 IO&lt;/h2&gt;
&lt;p&gt;Java IO 的各种流是&lt;strong&gt;阻塞&lt;/strong&gt;的 IO 操作。这就意味着，当一个线程执行读或写 IO 操作时，该线程会被&lt;strong&gt;阻塞&lt;/strong&gt;，直到有一些数据被读取，或者数据完全写入。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Java NIO 可以让我们&lt;strong&gt;非阻塞&lt;/strong&gt;的使用 IO 操作。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当一个线程执行从 Channel 执行读取 IO 操作时，当此时有数据，则读取数据并返回；当此时无数据，则直接返回&lt;strong&gt;而不会阻塞当前线程&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当一个线程执行向 Channel 执行写入 IO 操作时，&lt;strong&gt;不需要阻塞等待它完全写入&lt;/strong&gt;，这个线程同时可以做别的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，线程可以将非阻塞 IO 的空闲时间用于在其他 Channel 上执行 IO 操作。所以，一个单独的线程，可以管理多个 Channel 的读取和写入 IO 操作。&lt;/p&gt;
&lt;h2 id=&#34;httpsvipiocodercnnettynio-1-intro3-3-selector-33-selector33-selector&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#3-3-Selector&#34;  title=&#34;3.3 Selector&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;3.3 Selector&lt;/h2&gt;
&lt;p&gt;Java NIO 引入 Selector ( 选择器 )的概念，它是 Java NIO 得以实现非阻塞 IO 操作的&lt;strong&gt;最最最关键&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以注册&lt;strong&gt;多个&lt;/strong&gt; Channel 到&lt;strong&gt;一个&lt;/strong&gt; Selector 中。而 Selector 内部的机制，就可以自动的为我们不断的执行查询( select )操作，判断这些注册的 Channel 是否有&lt;strong&gt;已就绪的 IO 事件( 例如可读，可写，网络连接已完成 )&lt;/strong&gt;。&lt;br&gt;
通过这样的机制，&lt;strong&gt;一个&lt;/strong&gt;线程通过使用&lt;strong&gt;一个&lt;/strong&gt; Selector ，就可以非常简单且高效的来管理&lt;strong&gt;多个&lt;/strong&gt; Channel 了。&lt;/p&gt;
&lt;h1 id=&#34;httpsvipiocodercnnettynio-1-intro4-nio-e5928c-aio-e79a84e5afb9e6af94-4-nio-和-aio-的对比4-nio-和-aio-的对比&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;http://svip.iocoder.cn/Netty/nio-1-intro/#4-NIO-%E5%92%8C-AIO-%E7%9A%84%E5%AF%B9%E6%AF%94&#34;  title=&#34;4. NIO 和 AIO 的对比&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;4. NIO 和 AIO 的对比&lt;/h1&gt;
&lt;p&gt;考虑到 Netty 4.1.X 版本实际并未基于 Java AIO 实现，所以我们就省略掉这块内容。那么，感兴趣的同学，可以自己 Google 下 Java NIO 和 Java AIO 的对比。&lt;/p&gt;
&lt;p&gt;具体为什么 Netty 4.1.X 版本不支持 Java AIO 的原因，可参见 &lt;a class=&#34;link&#34; href=&#34;https://juejin.im/entry/5a8ed33b6fb9a0634c26801c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《Netty（二）：Netty 为啥去掉支持 AIO ?》&lt;/a&gt; 文章。&lt;/p&gt;
&lt;p&gt;也因此，Netty 4.1.X 一般情况下，使用的是&lt;strong&gt;同步非阻塞的 NIO 模型&lt;/strong&gt;。当然，如果真的有必要，也可以使用&lt;strong&gt;同步阻塞的 BIO 模型&lt;/strong&gt;。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
